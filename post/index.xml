<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Все записи в блоге on Где-то на дальнем сервере</title>
    <link>https://vporoshok.me/post/</link>
    <description>Recent content in Все записи в блоге on Где-то на дальнем сервере</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    
	<atom:link href="https://vporoshok.me/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Работа над задачей</title>
      <link>https://vporoshok.me/post/2021/04/work/</link>
      <pubDate>Fri, 09 Apr 2021 12:34:13 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2021/04/work/</guid>
      <description>Каждый день по работе я сталкиваюсь с разными задачами. Принципы работы с ними складывались как-то спонтанно, местами ценой набитых шишек. В этой статье хочу собрать всё и структурировать. В основном для себя, но вдруг окажется полезным ещё кому-нибудь.
Что важно Задачи можно решать разными способами, это как с сортировкой. В конце концов можно писать код до тех пор, пока задача не решится (возможно через пару лет усердного труда отдела программистов).</description>
    </item>
    
    <item>
      <title>Залогируй это</title>
      <link>https://vporoshok.me/post/2020/07/logs/</link>
      <pubDate>Wed, 15 Jul 2020 19:25:46 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2020/07/logs/</guid>
      <description>С самого начала моей карьеры программиста я на каждом углу встречал напутствия в стиле: «Пишите как можно больше логов, логируйте всё». Но все попытки логировать всё подряд приводили лишь к огромным файлам, в которых ничего не понять. И нигде мне не встречалось вразумительного руководства что и как надо логировать. Что ж, накопив немного опыта, давайте попробуем разобраться в этом вопросе.
Роли и задачи Прежде чем определять что писать в логи, необходимо разобраться кто и с какой целью их будет читать, ведь от модели использования будет зависеть ожидаемое содержимое.</description>
    </item>
    
    <item>
      <title>Распределённые алгоритмы</title>
      <link>https://vporoshok.me/post/2020/01/distributed-algorithms/</link>
      <pubDate>Tue, 07 Jan 2020 13:37:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2020/01/distributed-algorithms/</guid>
      <description>В этой заметке разбираются базовые понятия и определения, используемые при рассмотрении распределённых систем и алгоритмов, выполняемых на них. Терминология позаимствована из книги Уона Фоккинка «Распределенные алгоритмы. Интуитивный подход»1.
Что такое распределённая система? Определение распределённой системы базируется на определениях её базовых частей. Подходы же, применяемые в алгоритмах, рассчитанных на распределённое вычисление находят применение и за пределами распределённых систем в их базовом понимании. Поэтому будем понимать определение распредённой системы расширено.
Базовой составляющей распределённой системы является процесс.</description>
    </item>
    
    <item>
      <title>Readme Driven Development</title>
      <link>https://vporoshok.me/post/2019/10/rdd/</link>
      <pubDate>Sun, 13 Oct 2019 10:21:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/10/rdd/</guid>
      <description>Технари всегда начинают разговор с «нет», потому что думают о том, как это реализовывать, а тут надо «парить»… Будин А.В.   В этой статье попробуем разобраться о том, как проектировать программные интерфейсы. Интерфейсы могут быть совершенно разными, однако, есть в них одна общая черта: программисты разрабатывают их для других программистов. И это будет нашим большим плюсом, потому что мы также можем выступать в роли потребителей собственных продуктов. Итак, вы решили разработать библиотеку или сервис.</description>
    </item>
    
    <item>
      <title>SICP: 1.1 Элементы программирования</title>
      <link>https://vporoshok.me/post/2019/10/sicp-elementary/</link>
      <pubDate>Fri, 04 Oct 2019 15:17:31 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/10/sicp-elementary/</guid>
      <description>Префиксная нотация и комбинации Программа на языке Лисп представляет из себя набор комбинаций (combination) и особых форм (special form). Комбинациями называются кортежи, состоящие из команды и операндов (аргументов):
(&amp;lt;op&amp;gt; &amp;lt;arg1&amp;gt; [...&amp;lt;args&amp;gt;]) В качестве операции могут выступать базовые арифметические операции, встроенные в язык (+, -, * и /). Например
(+ 8 4) ;&amp;gt; 12 (здесь и далее ответы интерпретатора пишутся в комментарии, начинающемся с ;&amp;gt;)
(/ 128 8) ;&amp;gt; 16 Первое время кажется сложным воспринимать такую запись, где операция предшествует операндам.</description>
    </item>
    
    <item>
      <title>Быстро пишем функциональные тесты</title>
      <link>https://vporoshok.me/post/2019/08/quick-test/</link>
      <pubDate>Sun, 25 Aug 2019 15:44:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/quick-test/</guid>
      <description>Пара слов о классификации тестов Напомню, что традиционно выделяют следующие виды тестов:
 Модульные &amp;mdash; они же юнит-тесты. Это тесты изолированные внутри пакета/модуля, которые тестируют отдельные методы классов и помогают при разработке. Функциональные &amp;mdash; тесты, обращающиеся к пакету/модулю как к чёрному ящику, вызывая только публичные методы. Интеграционные &amp;mdash; (и их подвиды: end-to-end и сценарные тесты) проводятся в среде приближенной к рабочей, с реальными бд и другими сервисами.  Не вдаваясь в холивары, будем придерживаюсь той точки зрения, что модульные тесты это инструмент для разработки, когда есть сложная логика, которую легко протестировать.</description>
    </item>
    
    <item>
      <title>Действия в действии</title>
      <link>https://vporoshok.me/post/2019/08/actions-in-action/</link>
      <pubDate>Wed, 21 Aug 2019 03:25:57 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/actions-in-action/</guid>
      <description>В статье Чистая архитектура на Go предлагается изолировать бизнес-логику микросервиса в так называемых Действиях. В данной статье разбираются различные наработанные практики и подходы по написанию Действий.
DIContainer Практически любое действие так или иначе зависит от внешних систем, будь то база данных, файловая система, часы или логер. Всё, что связано с побочными эффектами. Собрать все зависимости в один объект, идея не новая, но в контексте Go несколько кропотливая. Итак, до создания первого действия необходимо описать зависимости.</description>
    </item>
    
    <item>
      <title>SICP: Введение</title>
      <link>https://vporoshok.me/post/2019/07/sicp-intro/</link>
      <pubDate>Tue, 30 Jul 2019 09:16:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/07/sicp-intro/</guid>
      <description>В очередной раз взялся за эту книгу, признанную фундаментальной для изучения программирования, основу для многих курсов и по сей день актуальную. Итак, знаменитая СИКП или книга Структура и интерпретация компьютерных программ. Эта книга, написанная в MIT, является классическим учебником программирования, используемым во многих университетах по всему миру.
Эта книга проводит читателя от азов программирования до сложных конструкций, вплоть до построения собственного интерпретатора языка. В ней разбирается то, как работает с кодом программ компьютер, а также то, как удобнее работать с ним человеку.</description>
    </item>
    
    <item>
      <title>Полезные приёмы по работе с ошибками в Go</title>
      <link>https://vporoshok.me/post/2019/05/errors/</link>
      <pubDate>Sat, 04 May 2019 19:12:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/05/errors/</guid>
      <description>Язык Go поощряет использование возвращаемых ошибок, при этом не накладывая больших ограничений на то, что скрывается внутри самой ошибки. Несмотря на многословность, подобную практику можно выгодно использовать. Давайте посмотрим какие удобные способы работы есть с ошибками.
pkg/errors Первое, что необходимо включить в свой проект, это библиотеку github.com/pkg/errors, которая позволяет быстро конструировать ошибки, а также добавлять контекст и, конечно, стек вызова. Лично у меня пальцы уже автоматом набирают
return errors.WithStack(err) Одной из ключевых особенностей ошибок, созданных с помощью пакета, является то, что у них есть метод Cause, позволяющий получить первоначальную ошибку.</description>
    </item>
    
    <item>
      <title>O3: разговоры тет-а-тет</title>
      <link>https://vporoshok.me/post/2019/03/one-on-one/</link>
      <pubDate>Sun, 17 Mar 2019 17:35:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/03/one-on-one/</guid>
      <description>Разговоры один на один между куратором и сотрудниками часто в англоязычных источниках называются one-on-one или просто O3. Для многих компаний это обычная практика, а среди европейских it-компаний уже трудно найти ту, где такие сессии не проводятся. Так давайте разбираться что это, для чего и как.
Что же такое O3? O3 это приватная встреча между куратором и сотрудником. Такие встречи обычно проводятся раз в одну или две недели. На этих встречах обсуждаются текущее состояние сотрудника, его переживания связанные с работой, вопросы, которые не столь критичны, что требуют незамедлительной реакции, но важны в перспективе.</description>
    </item>
    
    <item>
      <title>Декораторы в Go</title>
      <link>https://vporoshok.me/post/2019/01/decorators/</link>
      <pubDate>Thu, 24 Jan 2019 16:25:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/decorators/</guid>
      <description>Довольно большая часть моей работы заключается в написании библиотечного кода. Кода, который будет многократно использоваться как другими программистами, так и мной самим. Поэтому одним из важных критериев становится удобство интерфейсов. Некоторые применяемые мной практики рассмотрены в этой статье.
Перехватчики Концепция middleware появилась, конечно, задолго до go. Будем называть их перехватчиками, что не по фен-шую, но лучше, чем «слой промежуточного программного обеспечения». Однако, именно в go эта концепция достигла своего апогея.</description>
    </item>
    
    <item>
      <title>Рефлексия в Go</title>
      <link>https://vporoshok.me/post/2019/01/reflection/</link>
      <pubDate>Sun, 20 Jan 2019 05:30:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/reflection/</guid>
      <description>Зачем ты озабочен
В этот хороший миг одним упорным выяснением,
Как тебя люди другие видят. Тратишь воображение
На домыслы пустые о домыслах касательно своей персоны.
У тебя рефлексия, опасная стадия. Есть есть есть «Рефлексия»    Что же такое рефлексия и для чего она нужна? Рефлексия это механизм, с помощью которого программа может проверять своё состояние, исследовать типы данных и менять свою структуру и поведение во время выполнения. Звучит довольно запутано, но давайте раскладывать по полочкам.</description>
    </item>
    
    <item>
      <title>Хакатон. Как не перестать улыбаться за 24 часа</title>
      <link>https://vporoshok.me/post/2019/01/hackathon/</link>
      <pubDate>Thu, 03 Jan 2019 08:08:58 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/hackathon/</guid>
      <description>Что же такое хакатон? Термин «хакатон» является словослиянием двух слов: хак (hack) и марафон (marathon).
Впервые это слово появляется в 1999 году независимо друг от друга на двух событиях: встреча разработчиков OpenBSD и конференция JavaOne. В первом случае 10 человек в течении дня разрабатывали криптографические программы, которые бы обходили ограничения США на экспорт криптографических систем, а во втором случае всем желающим было предложено в течении конференции разработать программу на Java для Palm V с использованием ИК-порта.</description>
    </item>
    
    <item>
      <title>Деревья поиска. АВЛ-деревья</title>
      <link>https://vporoshok.me/post/2018/12/search-tree/</link>
      <pubDate>Thu, 20 Dec 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/12/search-tree/</guid>
      <description>Большие объёмы данных требуют особых подходов к задаче поиска. Если для нахождения элемента среди пары сотен элементов за линейное время достаточно хорошо, то когда речь идёт о тысячах и миллионах элементов, линейное время оказывается неоправданно большим. Можно воспользоваться известным нам бинарным поиском или даже его адаптацией галопированием. Но и это оказывается неэффективно при работе с данными, не влезающими в оперативную память. Действительно, пусть у нас есть файл размера 1 Гб с отсортированными данными.</description>
    </item>
    
    <item>
      <title>Как и для чего изучать алгоритмы</title>
      <link>https://vporoshok.me/post/2018/11/introduction/</link>
      <pubDate>Thu, 29 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/introduction/</guid>
      <description>Иногда студенты, коллеги и знакомые задают мне вопросы о том
 почему нужно изучать алгоритмы? какой смысл в понимании оценок алгоритмов? для чего так много времени уделять алгоритмам, которые реализованы в стандартных библиотеках? пригождаются ли все эти знания в повседневной работе программиста? стоит ли разбираться javascript-разработчику с тем во что компилируется код на C и ассемблером вообще?  Отрывочно я старался отвечать на эти вопросы и раньше, однако теперь у меня сложилось более или менее целостное представление обо всех этих и многих других вопросах, кое я и попытаюсь изложить в этой статье.</description>
    </item>
    
    <item>
      <title>Кучи с эффективным слиянием</title>
      <link>https://vporoshok.me/post/2018/11/meldable-heaps/</link>
      <pubDate>Thu, 15 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/meldable-heaps/</guid>
      <description>В статье про двоичную кучу было рассказано про устройство такой структуры данных как куча, а также приведён пример реализации в виде двоичной кучи. Такая реализация обладает двумя бесспорными преимуществами: простотой и компактностью хранения. Однако одна операция, часто требуемая от кучи в ней имеет слишком высокую сложность, эта операция слияние (meld). По сути лучшим способом слияния двоичных куч является построение новой кучи на объединённом массиве элементов. Сложность такой операции будет \(O(n + m)\) или, если одна из сливаемых куч сильно меньше другой, то можно поэлементно добавить первую ко второй, получив сложность \(O(n \log m)\).</description>
    </item>
    
    <item>
      <title>Слияние больших массивов данных</title>
      <link>https://vporoshok.me/post/2018/11/merge-sort-2/</link>
      <pubDate>Thu, 08 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/merge-sort-2/</guid>
      <description>Итак, изучив кучи в первом приближении, можно вернуться к сортировке слиянием и рассмотреть те случаи, где другая сортировка работать не будет в принципе. Речь на этот раз пойдёт о таких объёмах данных, которые не влезают в оперативную (внутреннюю) память.
Об уровнях памяти Часто, говоря о памяти компьютера, предлагают рассматривать лишь оперативную (RAM) и дисковую (HDD / SSD). На самом деле уровней памяти в современном компьютере значительно больше. Если упростить некоторые вещи, то можно рассматривать следующую иерархию:</description>
    </item>
    
    <item>
      <title>Простая двоичная куча</title>
      <link>https://vporoshok.me/post/2018/11/simple-heap/</link>
      <pubDate>Fri, 02 Nov 2018 15:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/simple-heap/</guid>
      <description>Часто возникает необходимость «сортировать» динамический набор данных. Самым ярким примером такой задачи является очередь с приоритетом. По сути задача сводится к последовательному выбору минимумов из множества, при этом допускающего добавление к множеству новых элементов. Конечно, эту задачу можно решить с помощью сортировки начального множества, а новые элементы можно включать с помощью бинарной вставки. Однако, есть структуры данных, позволяющие реализовать необходимые операции за меньшую стоимость. Такая структура называется куча (heap).</description>
    </item>
    
    <item>
      <title>Сортировка слиянием</title>
      <link>https://vporoshok.me/post/2018/10/merge-sort/</link>
      <pubDate>Sat, 27 Oct 2018 08:53:31 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/10/merge-sort/</guid>
      <description>Сортировка слиянием один из тех редких алгоритмов, которые не устаревают, а напротив год от года развивается, получает новые публикации и исследования. Это действительно чудесный со многих сторон алгоритм, который находит применение в современном мире, а исследования, связанные с ним предлагают решения, применимые далеко за пределами сортировки. Это своего рода жемчужина среди всех алгоритмов сортировки.
Базовый алгоритм Mergesort является двойственным к быстрой сортировке и относится к классу алгоритмов «Разделяй и властвуй».</description>
    </item>
    
    <item>
      <title>Разочарование в ревью кода</title>
      <link>https://vporoshok.me/post/2018/08/code-review/</link>
      <pubDate>Sat, 18 Aug 2018 16:51:41 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/08/code-review/</guid>
      <description>⚠️Внимание!В этой статье я лишь поднимаю проблемы и вопросы, не давая ответы, потому что не знаю их на сегодняшний день. При этом всё, что описано в статье, лишь мой опыт и не претендует на истину в последней инстанции. На протяжении последних нескольких лет я довольно активно пропагандировал ревью кода. Когда я только пришёл в компанию, в том отделе, куда меня взяли, не применялся даже git, а о ревью кода и вовсе не слышали.</description>
    </item>
    
    <item>
      <title>Отдельный блог</title>
      <link>https://vporoshok.me/post/2018/06/goto-standalone-blog/</link>
      <pubDate>Sat, 16 Jun 2018 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/goto-standalone-blog/</guid>
      <description>Уже несколько раз я пытался вести собственный блог. Какое-то время вёл ЖЖ, по большей части похожий на дневник. Потом я несколько раз пытался завести технический блог, но хватало меня на пару постов, после чего всё угасало. И вот недавно я всё же решил вести технический блог на регулярной основе (регулярностью, конечно, и не пахнет, но всё же). Несмотря на то, что я уже пробовал различные генераторы статических сайтов, сделал выбор в сторону платформы и завёл https://medium.</description>
    </item>
    
    <item>
      <title>Property-based testing</title>
      <link>https://vporoshok.me/post/2018/06/property-based-testing/</link>
      <pubDate>Tue, 12 Jun 2018 16:09:44 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/property-based-testing/</guid>
      <description>Сегодня хотелось бы рассмотреть такой подход к тестированию как property-based тесты, или, по-русски говоря, тесты основанные на свойствах. Раньше, когда я слышал это название, то думал, что это способы тестирования свойств классов, в смысле property. А при учёте того, что я слышал об этом исключительно в подкасте DevZen, где за этими словами следовали слова: haskell, scala и erlang, то не особо вдавался в подробности. Однако, на выпуске про TLA+ эта тема меня всё же зацепила, так что я пошёл гуглить и читать.</description>
    </item>
    
    <item>
      <title>Чистая архитектура на Go</title>
      <link>https://vporoshok.me/post/2018/04/clean-architect/</link>
      <pubDate>Sun, 15 Apr 2018 14:14:40 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/clean-architect/</guid>
      <description>О том, что такое чистая архитектура можно почитать в оригинале, а также в переводе. Кроме того на том же хабре есть переводы статей о переложении этого подхода на Go: раз, два и три. Но все это разбивается о реальную жизнь, транзакции, переиспользование кода, протомонолит и прочие проблемы. Но обо всём по порядку.
 ⚠️Внимание!Всё описанное является сугубо моим мнением, основанным на некотором количестве боли, испытываемой в работе, особенно с циклическими импортами.</description>
    </item>
    
    <item>
      <title>Чек-лист разработчика</title>
      <link>https://vporoshok.me/post/2018/04/developer-check-list/</link>
      <pubDate>Sun, 08 Apr 2018 07:49:35 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/developer-check-list/</guid>
      <description>Всегда В первую очередь надо не забывать о правилах хорошего тона. Оскорбления не разрешаются никому и никогда. Мат тоже желательно исключить из лексикона. Мы должны работать вместе, а не против друг друга, поэтому иногда надо идти на компромиссы. Ясно и чётко излагай свои мысли, аргументируй и доказывай, и тебя услышат.
TL;DR Git
 сообщение должно точно описано где, что и почему было сделано; обновление завендоренных зависимостей, изменения, не относящиеся напрямую к задаче и правки по ревью всегда оформляются отдельным коммитом;  Отчёты</description>
    </item>
    
    <item>
      <title>Цикл статей про Angular</title>
      <link>https://vporoshok.me/post/2018/04/angular-toc/</link>
      <pubDate>Sun, 08 Apr 2018 07:24:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/angular-toc/</guid>
      <description>Мы начали использовать Angular (в то время Angular 2) на одном из проектов нашей компании примерно в сентябре 2016 года. Тогда он только вышел из беты. За плечами у нас не было опыта использования никакого фреймворка, разве что Backbone, но фреймворком его можно назвать лишь с натяжкой. Проект же требовал довольно развесистого веб-приложения. Мы немного пощупали Ember, посмотрели на React, даже попытались воспользоваться Backbone+Marionette, но в итоге остановились на Angular. Порой он причинял нам боль, порой мы упирались в совершенно необъяснимое поведение.</description>
    </item>
    
    <item>
      <title>Разрешение орграфа</title>
      <link>https://vporoshok.me/post/2017/06/orgraph-resolve/</link>
      <pubDate>Sun, 04 Jun 2017 17:00:30 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/06/orgraph-resolve/</guid>
      <description>По работе уже не первый раз сталкиваюсь с задачей разрешения графа, например, получить полный список зависимостей пакета или получить список групп пользователя, где группы могут включать друг друга. (Вообще граф зависимостей куда сложнее текущей темы, потому как дуги имеют маски версий, так что отложим этот вопрос на будущее.)
Итак, давайте сформулируем и ограничим задачу. У нас есть (в общем случае) ориентированный граф. Каждая вершина имеет уникальное имя и связанные с ней данные.</description>
    </item>
    
    <item>
      <title>Ещё раз о безопасности или где хранить токен</title>
      <link>https://vporoshok.me/post/2017/05/token-placement/</link>
      <pubDate>Sun, 28 May 2017 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/05/token-placement/</guid>
      <description>В очередной раз встал вопрос о том где и как хранить токен авторизации. Первое что приходит в голову это cookie. Итак, давайте сделаем простенький сайт со странице авторизации и использованием cookie для определения пользователя, а затем попробуем его поломать. Использовать мы будем CSRF атаку. Об этих атаках написано уже немало статей, небольшой список будет в конце. В данном посте хочется добавить практики в эти объяснения на пальцах. Для удобства используем репозиторий с тегами эволюции проекта https://github.</description>
    </item>
    
  </channel>
</rss>