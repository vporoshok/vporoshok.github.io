<!DOCTYPE html>
<html lang='ru'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='В этой заметке разбираются базовые понятия и определения, используемые при рассмотрении распределённых систем и алгоритмов, выполняемых на них. Терминология позаимствована из книги Уона Фоккинка «Распределенные алгоритмы. Интуитивный подход»1.
Что такое распределённая система? Определение распределённой системы базируется на определениях её базовых частей. Подходы же, применяемые в алгоритмах, рассчитанных на распределённое вычисление находят применение и за пределами распределённых систем в их базовом понимании. Поэтому будем понимать определение распредённой системы расширено.
Базовой составляющей распределённой системы является процесс.'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Распределённые алгоритмы • Где-то на дальнем сервере'>
<meta property='og:description' content='В этой заметке разбираются базовые понятия и определения, используемые при рассмотрении распределённых систем и алгоритмов, выполняемых на них. Терминология позаимствована из книги Уона Фоккинка «Распределенные алгоритмы. Интуитивный подход»1.
Что такое распределённая система? Определение распределённой системы базируется на определениях её базовых частей. Подходы же, применяемые в алгоритмах, рассчитанных на распределённое вычисление находят применение и за пределами распределённых систем в их базовом понимании. Поэтому будем понимать определение распредённой системы расширено.
Базовой составляющей распределённой системы является процесс.'>
<meta property='og:url' content='https://vporoshok.me/post/2020/01/distributed-algorithms/'>
<meta property='og:site_name' content='Где-то на дальнем сервере'>
<meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='graph'><meta property='article:tag' content='state-machine'><meta property='article:tag' content='distributed system'><meta property='article:published_time' content='2020-01-07T13:37:25Z'/><meta property='article:modified_time' content='2021-10-01T18:45:33&#43;04:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.88.1" />

  <title>Распределённые алгоритмы • Где-то на дальнем сервере</title>
  <link rel='canonical' href='https://vporoshok.me/post/2020/01/distributed-algorithms/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='/assets/css/main.6a060eb7.css'><link rel='stylesheet' href='/assets/custom.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-41042060-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head>
<body class='page type-post has-sidebar'>

  <div class='site'><div id='sidebar' class='sidebar'>
  <a class='screen-reader-text' href='#main-menu'>Перейти к основному меню</a>

  <div class='container'><section class='widget widget-about sep-after'>
  <header>
    
    <div class='logo'>
      <a href='/'>
        <img src='/images/logo.jpg' alt="Вернуться на главную">
      </a>
    </div>
    
    <h2 class='title site-title '>
    vporoshok.me
    </h2>
    <div class='desc'>
    Где-то на дальнем сервере
    </div>
  </header>

</section>
<section class='widget widget-social_menu sep-after'><nav aria-label='Соцсети'>
    <ul><li>
        <a href='https://twitter.com/vporoshok' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Открыть Twitter-акаунт в новой вкладке</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
  
</svg>
</a>
      </li><li>
        <a href='https://github.com/vporoshok' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Открыть Github-акаунт в новой вкладке</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
  
</svg>
</a>
      </li><li>
        <a href='mailto:vporoshok@gmail.com' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Связаться через Email</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
  <polyline points="22,6 12,13 2,6"/>
  
</svg>
</a>
      </li><li>
        <a href='https://t.me/vporoshok' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Открыть Telegram-акаунт в новой вкладке</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="m 22.05,1.577 c -0.393,-0.016 -0.784,0.08 -1.117,0.235 -0.484,0.186 -4.92,1.902 -9.41,3.64 C 9.263,6.325 7.005,7.198 5.267,7.867 3.53,8.537 2.222,9.035 2.153,9.059 c -0.46,0.16 -1.082,0.362 -1.61,0.984 -0.79581202,1.058365 0.21077405,1.964825 1.004,2.499 1.76,0.564 3.58,1.102 5.087,1.608 0.556,1.96 1.09,3.927 1.618,5.89 0.174,0.394 0.553,0.54 0.944,0.544 l -0.002,0.02 c 0,0 0.307,0.03 0.606,-0.042 0.3,-0.07 0.677,-0.244 1.02,-0.565 0.377,-0.354 1.4,-1.36 1.98,-1.928 l 4.37,3.226 0.035,0.02 c 0,0 0.484,0.34 1.192,0.388 0.354,0.024 0.82,-0.044 1.22,-0.337 0.403,-0.294 0.67,-0.767 0.795,-1.307 0.374,-1.63 2.853,-13.427 3.276,-15.38 L 23.676,4.725 C 23.972,3.625 23.863,2.617 23.18,2.02 22.838,1.723 22.444,1.593 22.05,1.576 Z"/>
  
</svg>
</a>
      </li></ul>
  </nav>
</section><section class='widget widget-sidebar_menu sep-after'><nav id='sidebar-menu' class='menu sidebar-menu' aria-label='Боковое меню'>
    <div class='container'>
      <ul><li class='item'>
  <a href='/categories/algorithm/'>Алгоритмы</a></li><li class='item'>
  <a href='/categories/develop/'>Разработка</a></li><li class='item'>
  <a href='/categories/life-style/'>Образ жизни</a></li><li class='item'>
  <a href='/categories/book/'>Книги</a></li><li class='item'>
  <a href='/slides/'>Презентации</a></li><li class='item'>
  <a href='/categories/project/'>Проекты</a></li></ul>
    </div>
  </nav>

</section><section class='widget widget-taxonomy_cloud sep-after'>
  <header>
    <h4 class='title widget-title'>Тэги</h4>
  </header>

  <div class='container list-container'>
  <ul class='list taxonomy-cloud no-shuffle'><li>
        <a href='/tags/algorithm/' style='font-size:1em'>algorithm</a>
      </li><li>
        <a href='/tags/angular/' style='font-size:1em'>angular</a>
      </li><li>
        <a href='/tags/architect/' style='font-size:1.625em'>architect</a>
      </li><li>
        <a href='/tags/blog/' style='font-size:1em'>blog</a>
      </li><li>
        <a href='/tags/checklist/' style='font-size:1.375em'>checklist</a>
      </li><li>
        <a href='/tags/complexity/' style='font-size:1.5em'>complexity</a>
      </li><li>
        <a href='/tags/csrf/' style='font-size:1em'>CSRF</a>
      </li><li>
        <a href='/tags/data-structure/' style='font-size:1.375em'>data-structure</a>
      </li><li>
        <a href='/tags/distributed-system/' style='font-size:1em'>distributed system</a>
      </li><li>
        <a href='/tags/event/' style='font-size:1em'>event</a>
      </li><li>
        <a href='/tags/git/' style='font-size:1em'>git</a>
      </li><li>
        <a href='/tags/go/' style='font-size:2em'>go</a>
      </li><li>
        <a href='/tags/graph/' style='font-size:1.125em'>graph</a>
      </li><li>
        <a href='/tags/hackathon/' style='font-size:1em'>hackathon</a>
      </li><li>
        <a href='/tags/keynote/' style='font-size:1em'>keynote</a>
      </li><li>
        <a href='/tags/logging/' style='font-size:1em'>logging</a>
      </li><li>
        <a href='/tags/management/' style='font-size:1.125em'>management</a>
      </li><li>
        <a href='/tags/memory/' style='font-size:1.25em'>memory</a>
      </li><li>
        <a href='/tags/microservices/' style='font-size:1.125em'>microservices</a>
      </li><li>
        <a href='/tags/orgmode/' style='font-size:1em'>orgmode</a>
      </li><li>
        <a href='/tags/php/' style='font-size:1em'>PHP</a>
      </li><li>
        <a href='/tags/python/' style='font-size:1.125em'>python</a>
      </li><li>
        <a href='/tags/rules/' style='font-size:1.125em'>rules</a>
      </li><li>
        <a href='/tags/rxjs/' style='font-size:1em'>rxjs</a>
      </li><li>
        <a href='/tags/scheme/' style='font-size:1.125em'>scheme</a>
      </li><li>
        <a href='/tags/scrum/' style='font-size:1.125em'>scrum</a>
      </li><li>
        <a href='/tags/security/' style='font-size:1em'>security</a>
      </li><li>
        <a href='/tags/sicp/' style='font-size:1.125em'>sicp</a>
      </li><li>
        <a href='/tags/sorting/' style='font-size:1em'>sorting</a>
      </li><li>
        <a href='/tags/state-machine/' style='font-size:1em'>state-machine</a>
      </li><li>
        <a href='/tags/team-lead/' style='font-size:1em'>team-lead</a>
      </li><li>
        <a href='/tags/testing/' style='font-size:1.125em'>testing</a>
      </li><li>
        <a href='/tags/tips-and-tricks/' style='font-size:1.25em'>tips and tricks</a>
      </li><li>
        <a href='/tags/toc/' style='font-size:1em'>toc</a>
      </li><li>
        <a href='/tags/tutorial/' style='font-size:1.125em'>tutorial</a>
      </li><li>
        <a href='/tags/typescript/' style='font-size:1em'>typescript</a>
      </li><li>
        <a href='/tags/web/' style='font-size:1em'>web</a>
      </li><li>
        <a href='/tags/work/' style='font-size:1em'>work</a>
      </li></ul>
</div>


</section>
</div>

  <div class='sidebar-overlay'></div>
</div><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Основное меню'>
  <div class='container'>
    <a class='screen-reader-text' href='#content'>Перейти к содержимому</a>

<button id='sidebar-toggler' class='sidebar-toggler' aria-controls='sidebar'>
  <span class='screen-reader-text'>Скрыть / показать боковую панель</span>
  <span class='open'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="3" y1="12" x2="21" y2="12" />
  <line x1="3" y1="6" x2="21" y2="6" />
  <line x1="3" y1="18" x2="21" y2="18" />
  
</svg>
</span>
  <span class='close'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
  
</svg>
</span>
</button>
    <ul><li class='item current'>
        <a aria-current='page' href='/post/'>Блог</a>
      </li><li class='item'>
        <a href='/page/about/'>Обо мне</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>Где-то на дальнем сервере</p><p class='desc site-desc'>Заметки о программировании и не только</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='ru' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Распределённые алгоритмы</h1>
      

    </div>
    
<div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Опубликовано </span>
  <time class='entry-date' datetime='2020-01-07T13:37:25Z'>2020-01-07</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
11 минут на чтение
</span>


  
</div>


  </div>
</header>

  
  
<details class='container entry-toc'>
  <summary class='title'>
    <span>Оглавление</span>
  </summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#что-такое-распределённая-система">Что такое распределённая система?</a>
      <ul>
        <li><a href="#сети-и-топология">Сети и топология</a></li>
      </ul>
    </li>
    <li><a href="#задачи">Задачи</a></li>
    <li><a href="#события">События</a>
      <ul>
        <li><a href="#каузуальный-порядок">Каузуальный порядок</a></li>
        <li><a href="#конфигурация-вычисления-и-система-переходов">Конфигурация, вычисления и система переходов</a></li>
        <li><a href="#логические-часы">Логические часы</a></li>
      </ul>
    </li>
    <li><a href="#утверждения">Утверждения</a></li>
    <li><a href="#управляющий-и-базовый-алгоритмы">Управляющий и базовый алгоритмы</a></li>
    <li><a href="#задания">Задания</a></li>
    <li><a href="#вопросы">Вопросы</a></li>
  </ul>
</nav>
</details>


  <div class='container entry-content'>
  <p>В этой заметке разбираются базовые понятия и определения, используемые при рассмотрении распределённых систем и алгоритмов, выполняемых на них. Терминология позаимствована из книги Уона Фоккинка «Распределенные алгоритмы. Интуитивный подход»<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<h2 id="что-такое-распределённая-система">Что такое распределённая система?</h2>
<p>Определение распределённой системы базируется на определениях её базовых частей. Подходы же, применяемые в алгоритмах, рассчитанных на распределённое вычисление находят применение и за пределами распределённых систем в их базовом понимании. Поэтому будем понимать определение распредённой системы расширено.</p>
<p>Базовой составляющей распределённой системы является <em>процесс</em>. Для определённости под процессом будем понимать машину состояний или конечный автомат<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. Если же собрать несколько таких изолированных процессов и добавить к ним возможность обмена сообщениями, получится распредённая система. То есть, <em>распредённой системой</em> будем называть совокупность процессов (конечных автоматов) с возможностью передачи между ними сообщений.</p>
<p>Стоит отметить, что процессы не обязательно должны быть запущенны на разных компьютерах, к примеру, выполнение <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2">системного вызова</a> по сути является обменом сообщениями с операционной системой, запуск <a href="https://nodejs.org/api/cluster.html">кластера процессов стандартными средствами nodejs</a> или выполнение параллельных вычислений на графическом процессоре тоже можно рассматривать как распределённую систему. Более того, многие среды выполнения имеют встроенные абстракции для создания сложных распределённых систем в рамках одной программы, такие как горутины в языке Go, стримы в языке Java, акторы во многих реализациях. А языке Erlang подобная абстракция позволяет программисту вообще не задумываться на скольких машинах выполняется программа, оперируя кластером компьютеров как единым целым.</p>
<h3 id="сети-и-топология">Сети и топология</h3>
<p>Однако, если обобщить, без привязки к конкретным имплементациям, то можно выделить такую абстракцию как сеть. <em>Сетью</em> будем называть средства передачи сообщений между процессами. При этом к сети мы будем подходить высокоуровнево, не вдаваясь в форматы и протоколы передачи данных, их фрагментирование и проверку целостности и тем более в физические способы доставки этих данных<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. Ограничимся представлением сети как набора каналов между процессами, где каждый канал связывает два процесса, предоставляя возможность передачи между ними сообщений.</p>
<p>Несмотря на подобное упрощение для каналов мы будем выделять следующие характеристики:</p>
<ol>
<li><strong>Направленность</strong> &mdash; является ли канал \(pq\) однонаправленным (то есть по нему возможна передача сообщений от процесса \(p\) к процессу \(q\), но не наоборот) или позволяет передавать сообщения в обоих направлениях (как от процесса \(p\) к процессу \(q\), так и в обратном направлении).</li>
<li><strong>Синхронность</strong> &mdash; совпадает ли отправка с получением по времени, либо же сообщение может некоторое время «существовать» в состоянии передачи, то есть, когда отправка уже завершена, а получение ещё не начато. Подобное поведение возможно при наличии промежуточных устройств в канале связи, способных буферизировать сообщения.</li>
<li><strong>Подтверждение</strong> или <strong>гарантия доставки</strong> &mdash; возможность отправителю получить подтверждение доставки сообщения получателю. Обычно это свойство гарантируется протоколом. Также стоит отметить, что асинхронные сети с подтверждением доставки можно представлять как синхронные(<a id="qback-1" href="#qlink-1">?</a>).</li>
<li><strong>Гарантия порядка</strong> &mdash; гарантия того, что канал ведёт себя по правилу <a href="https://ru.wikipedia.org/wiki/FIFO">First In First Out</a>, то есть, сообщения будут доставлены в том же порядке, что и были отправлены.</li>
<li><strong>Ограниченное время доставки</strong> &mdash; канал с ограниченным временем доставки позволяет рассчитывать на то, что сообщение будет доставлено не позднее, чем указанное время. Есть более слабый вариант этой характеристики, называемый, канал с <strong>ожидаемым временем доставки</strong>, когда вероятность, того, что сообщение будет доставлено с определённой задержкой тем меньше, чем больше это время (однако эта характеристика канала позволяет лишь оценить время выполнения алгоритма, но не влияет на его корректность).</li>
</ol>
<p>Кроме того, каналы и процессы образуют своего рода (ор)граф сети. То, каким образом связываются процессы сетью, обычно называют топологией сети. Классически выделяют следующие топологии:</p>
<ul>
<li><strong>полносвязанная сеть</strong> &mdash; между любой парой процессов есть канал связи;</li>
<li><strong>дерево</strong> &mdash; между любой парой процессов есть единственный маршрут, состоящий из каналов связи;</li>
<li><strong>(оринетированное) кольцо</strong> &mdash; все процессы соединены в кольцо или ориентированное кольцо;</li>
<li><strong>звезда</strong> &mdash; одноуровневое дерево;</li>
</ul>
<p>Часто используется смешанная топология, например, дерево, каждая вершина которого является полносвязанной сетью. Также часто применяется принцип поиска <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D1%82%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">остова сети</a>, для дальнейшей работы с сетью в рамках полученного дерева.</p>
<h2 id="задачи">Задачи</h2>
<p>Какие же задачи необходимо решать в такого рода системах? Так сложилось, что развитие вычислительных устройств, несмотря на геометрический рост, достигло своего предела в скорости выполнения операций. Уменьшение размеров полупроводников вызывает квантовые эффекты, с которыми мы только учимся работать. Вместо вертикального роста, куда более простым оказался горизонтальный, многоядерные архитектуры процессоров уже давно стали нормой. С другой стороны куда быстрее растут объёмы данных, над которыми необходимо выполнять операции. Хотя объёмы памяти, доступные для современных компьютеров, также растут, часто возникают задачи распределённого хранения и обработки данных. Другой причиной развития распределённых систем стала необходимость отказоустойчивости современных программ. Представьте, если бы данные вашего банка хранились на одном единственном компьютере, который внезапно вышел из строя. Задачи, решаемые распределёнными системами, возникают каждый день, однако, методы и подходы распределённых алгоритмов являются неизменными кирпичами, из которых строятся современные системы. Вот некоторые из них:</p>
<ul>
<li>синхронизация состояния;</li>
<li>конкурентный доступ к состоянию;</li>
<li>совместное принятие решения;</li>
<li>выбор лидера;</li>
<li>обнаружение блокировок;</li>
<li>обнаружение завершения;</li>
<li>маршрутизация сообщений;</li>
<li>резервирование данных;</li>
<li>устойчивость к сбоям;</li>
<li>устойчивость к внедрению злоумышленников;</li>
</ul>
<p>Для широкого круга задач сложность распределённых вычислений можно вынести из разрабатываемой системы во внешнюю, такую как база данных, кеш или очередь сообщений, полагаясь на гарантии этой внешней системы. Но для сложных и высоконагруженных систем ограничения внешних зависимостей могут стать бутылочным горлышком. С другой стороны, гарантии таких систем оказываются с большими сносками, подобно банковским договорам, а то и вовсе маркетинговой ложью<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>. Так что изучение распределённых систем необходимо хотя бы для того, чтобы понимать какие аномалии могут возникнуть, и, если не научиться их избегать, то понимать как их обнаружить и минимизировать последствия.</p>
<h2 id="события">События</h2>
<p>Для описания функционирования распределённых систем удобно использовать такое понятие как событие. <em>Событием</em> будем называть изменение состояния системы. События бывают следующих видов:</p>
<ul>
<li><em>внутреннее (internal)</em> событие изменения внутреннего состояния одного из процессов системы;</li>
<li><em>отправка (send)</em> событие отправки сообщения от одного процесса другому;</li>
<li><em>получение (receive)</em> событие получения процессом сообщения, ранее отправленного ему другим процессом;</li>
</ul>
<h3 id="каузуальный-порядок">Каузуальный порядок</h3>
<p>События, происходящие в распределённой системе, имеют частичный порядок: каузуальный порядок или порядок причинности. Так при передачи сообщение от одного процесса другому, событие отправки предшествует событию получения. Событие же изменения внутреннего состояния в следствии получения сообщения, наступает позже получения. Таким образом мы можем частично упорядочить события. Например, пусть процесс \(p\) отправил процессу \(q\) сообщение \(\langle +1 \rangle\), а затем отправил процессу \(r\) сообщение \(\langle -1 \rangle\). Получив сообщение \(\langle +1 \rangle\), процесс \(q\) увеличил счётчик в своём внутреннем состоянии на единицу, а процесс \(r\), получив сообщение  \(\langle -1 \rangle\), уменьшил свой счётчик. Тогда, мы имеем следующие произошедшие события:</p>
<ol>
<li>процесс \(p\) отправил процессу \(q\) сообщение \(\langle +1 \rangle\) (send);</li>
<li>процесс \(p\) отправил процессу \(r\) сообщение \(\langle -1 \rangle\) (send);</li>
<li>процесс \(q\) получил от процесса \(p\) сообщение \(\langle +1 \rangle\) (receive);</li>
<li>процесс \(r\) получил от процесса \(p\) сообщение \(\langle -1 \rangle\) (receive);</li>
<li>процесс \(q\) изменил внутреннее состояние (internal);</li>
<li>процесс \(r\) изменил внутреннее состояние (internal);</li>
</ol>
<p>При этом мы можем утверждать, что событие 2 произошло позже, чем событие 1 (\(1 \prec 2\)), событие 3 произошло позже события 1 (\(1 \prec 3\)), но при этом мы не можем ничего сказать про порядок событий 2 и 3.</p>
<figure>
    <div class="mermaid">
graph LR
  A(1: p send q) --> B(2: p send r)
  A --> C(3: q receive by p)
  B --> D(4: r receive by p)
  C --> E(5: q change state)
  D --> F(6: r change state)
</div>
<figcaption>
        Рис. 1.
        
    </figcaption>
</figure>

<p>Будем говорить, что событие \(a\) каузуально предшествует событию \(b\) (\(a \prec b\)), если выполнено одно из следующих условий:</p>
<ul>
<li>оба события произошли в одном процессе и событие \(a\) произошло раньше события \(b\);</li>
<li>\(a\) является событием отправки сообщения, а \(b\) &mdash; событием получения этого сообщения;</li>
<li>существует событие \(c\), такое что: \(a \prec c\) и \(c \prec b\) (правило транзитивности);</li>
</ul>
<h3 id="конфигурация-вычисления-и-система-переходов">Конфигурация, вычисления и система переходов</h3>
<p>Так как мы считаем, что каждый процесс является конечным автоматом, то и всю систему можно рассматривать как более сложный конечный автомат, который меняет своё состояние при наступлении событий. Состояния могут менять как отдельные процессы при внутренних событиях, так и каналы связи при событиях отправки и получения сообщений. То есть под состоянием канала будем понимать набор сообщений, находящихся в процессе передачи через данный канал. Состояние всей системы будем называть <em>конфигурацией</em>.</p>
<p><em>Вычислением</em> распределённого алгоритма будем называть последовательность смены конфигураций системы. Вычисление может быть конечным или бесконечным. Но, если вернуться к примеру выше, где процесс \(p\) отправлял сообщения процессам \(q\) и \(r\), то надо заметить, что приведённый порядок лишь один из возможных. Действительно, утверждая, что событие 1 предшествует событию 2, мы ничего не можем сказать про порядок событий 2 и 3. Такие события называются независимыми, несравнимыми или параллельными. Таким образом, мы можем записать следующее вычисление, результат которого будет эквивалентен приведённому выше:</p>
<ol>
<li>процесс \(p\) отправил процессу \(q\) сообщение \(\langle +1 \rangle\) (send);</li>
<li>процесс \(q\) получил от процесса \(p\) сообщение \(\langle +1 \rangle\) (receive);</li>
<li>процесс \(q\) изменил внутреннее состояние (internal);</li>
<li>процесс \(p\) отправил процессу \(r\) сообщение \(\langle -1 \rangle\) (send);</li>
<li>процесс \(r\) получил от процесса \(p\) сообщение \(\langle -1 \rangle\) (receive);</li>
<li>процесс \(r\) изменил внутреннее состояние (internal);</li>
</ol>
<p>Упорядочивание параллельных событий называется сериализацией (serialization). Количество возможных вариантов сериализации таких событий комбинаторно возрастает с ростом параллельных событий(<a id="qback-2" href="#qlink-2">?</a>). При этом алгоритм должен корректно вести себя для любого варианта сериализации. Таким образом множество конфигураций образует ориентированный граф, где каждая дуга \((\gamma\delta)\) предполагает возможное событие в системе, переводящее её из конфигурации \(\gamma\) в конфигурацию \(\delta\) и называется <em>переходом</em> из конфигурации \(\gamma\) в конфигурацию \(\delta\).</p>
<p>Таким образом поведение распределённой системы можно описать следующей тройкой:</p>
<ul>
<li>множество конфигураций \(\Gamma\);</li>
<li>бинарное отношение перехода \(\to\), определённого на множестве \(\Gamma\);</li>
<li>множество <em>начальных</em> конфигураций \(I \subseteq \Gamma\).</li>
</ul>
<p>Тройку \((\Gamma, \to, I)\) будем называть <em>системой переходов</em>.</p>
<p>Конфигурацию будем называть <em>терминальной</em>, если не существет исходящего из неё перехода. Тогда вычисление можно определить как маршрут в орграфе \((\Gamma, \to)\), начинающийся в вершине из множества \(I\) и заканчивающийся в терминальной вершине, либо зацикливающийся для бесконечного вычисления.</p>
<p>Конфигурацию бедм называть <em>достижимой</em>, если существует маршрут в орграфе \((\Gamma, \to)\), начинающийся в вершине из множества \(I\) и заканчивающийся в этой вершине.</p>
<h3 id="логические-часы">Логические часы</h3>
<p>Частой задачей в распределённой системе является поддержание некоторой абстракции для восстановления каузуального порядка событий. Эта задача возникает из того ограничения, что в системе из нескольких компьютеров трудно поддерживать единое абсолютное время. Не смотря на технологии синхронизации часов, такие как <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a>, компьютеры могут «дрейфовать» по времени. (Хотя, есть системы опирающиеся на синхронное абсолютное время<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>) С другой стороны для многих задач и нет необходимости в абсолютном времени, требуется лишь разрешить каузуальный порядок событий. Такая абстракция называется <em>логические часы</em>: логическими часами будем называть отображение \(С\) действующее из множества событий в частично упорядоченное множество, сохраняющее порядок (изотонное или монотонное отображение):
<div class="equation">
\[
a \prec b \Rightarrow C(a) < C(b).
\]
</div></p>
<p>Одним из вариантов построения логических часов являются <em>часы Лэмпорта</em><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>: каждому событию в соответствие ставится длинная самой длинной цепочки каузуально упорядоченных событий, предшествующих ему. То есть в приведённом выше примере, внутреннему событию \(a\) изменения состояния процесса \(q\) каузуально предшествует два события: отправка и получение сообщения, а внутреннему событию \(b\) изменения состояния процесса \(r\) каузуально предшествует три события: две отправки и одно получение. Другими словами \(LC(a) = 2\), а \(LC(b) = 3\), где \(LC\) &mdash; часы Лэмпорта.</p>
<p>Часы Лэмпорта удовлетворяют определению логических часов, но имеют один существенный недостаток: они могут упорядочивать параллельные события. Действительно, события \(a\) и \(b\) являются параллельными, то есть мы не можем утверждать, что одно из них обязательно должно наступить раньше другого. Однако, если ориентироваться на часы Лэмпорта, получается, что событие \(b\), наступило позже события \(a\). Другими словами, часы Лэмпорта являются монотонным отображением, но не изоморфным.</p>
<p>Для получения изоморфизма, можно воспользоваться <em>векторными часами</em>: каждому событию в соответствии ставится вектор, где каждому процессу системы \(p_i\) сопоставлена \(i\)-я компонента, которая равна количеству событий этого процесса, каузуально предшествующих данному событию. Например, пусть процессу \(p\) будем сопоставлять нулевую компоненту, процессу \(q\) &mdash; первую, а \(r\) &mdash; вторую. Тогда значение векторных часов для события \(a\) будет равно вектору \((1, 1, 0)\), а \(V\!C(b) = (2, 0, 1)\). Сравнивать же получившиеся вектора будем по следующему правилу:
<div class="equation">
\[
(k_0, k_1, \ldots, k_{N-1}) \leqslant (\ell_0, \ell_1, \ldots, \ell_{N-1}) \iff k_i \leqslant \ell_i, \forall i = 0, \ldots, N-1
\]
</div></p>
<h2 id="утверждения">Утверждения</h2>
<p>Говоря о конфигурациях распределённой системы, можно ввести такое понятие как <em>утверждение</em> &mdash; предикат относительно конфигурации, то есть отображение множества \(\Gamma\) в двоеточие \(\{0, 1\}\) (будем говорить, что утверждение \(P\) выполнено для конфигурации \(\gamma\), если \(P(\gamma) = 1\), иначе будем говорить, что утверждение не выполнено).</p>
<p>Будем называть утверждение <em>свойством безопасности</em>, если оно выполнено для любой достижимой конфигурации системы.</p>
<p>Будем называть утверждение <em>инвариантом</em>, если оно выполнено для всех начальных конфигураций, а также, если оно выполнено для конфигурации \(\gamma\) и существует переход \(\gamma \to \delta\), то оно выполнено и для конфигурации \(\delta\). Очевидно, что инвариант является свойством безопасности, но наоборот(<a id="qback-3" href="#qlink-3">?</a>).</p>
<p>Утверждение будем называть <em>свойством живучести</em>, если любая цепочка выполнения обязана содержать конфигурацию, на которой это утверждение выполнится. Примером свойства живучести является, например, свойство того, что при подбрасывании монетки, рано или поздно выпадет решка. Конечно, здесь подразумевается <em>справедливая</em> или <em>честная</em> система событий.</p>
<h2 id="управляющий-и-базовый-алгоритмы">Управляющий и базовый алгоритмы</h2>
<p>Так как многие распределённые алгоритмы являются лишь частями более крупных алгоритмов, вспомогательными средствами, то их следует всегд рассматривать выполняемыми на фоне работы других алгоритмов. То есть, помимо сообщений, необходимых для работы рассматриваемого алгоритма, в каналах могут также передаваться другие сообщения, о назначении которых рассматриваемый алгоритм не имеет представления. Рассматриваемый алгорим будем называть <em>управляющим</em>, а фоновый &mdash; <em>базовым</em>. Иногда алгоритмы можно рассматривать независимо друг от друга, но иногда для корректности выполнения управляющего алгоритма необходимо модифицировать и отслеживать сообщения, передаваемый базовым алгоритмом.</p>
<h2 id="задания">Задания</h2>
<ol>
<li>Подумайте, каким образом можно поддерживать часы Лэмпорта в распределённой системе? Сыграйте втроём или вчетвером в «подкидного», где каждое взятие или выкладывание карты на стол является событием. Посчитайте значение часов Лэмпорта для каждого события партии.</li>
<li>Докажите, что векторные часы являются изоморфизмом.</li>
</ol>
<h2 id="вопросы">Вопросы</h2>
<ol>
<li><a id="qlink-1" href="#qback-1">^</a> Как асинхронную сеть с подтверждением можно свести к синхронной?</li>
<li><a id="qlink-2" href="#qback-2">^</a> Сколько существует вариантов сериализации событий, приведённых на рисунке 1?</li>
<li><a id="qlink-3" href="#qback-3">^</a> Придумайте свойство безопасности, не являющееся инвариантом.</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Уон Фоккинк <em>Распределенные алгоритмы. Интуитивный подход</em> &mdash; СПб.: Питер, 2016 &mdash; 272 с.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://ru.wikipedia.org/wiki/">https://ru.wikipedia.org/wiki/</a>Конечный_автомат&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://ru.wikipedia.org/wiki/">https://ru.wikipedia.org/wiki/</a>Сетевая_модель_OSI&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>Блог Афира, где он публикует результаты тестов распределённых систем на соответствие заявленным гарантиям: <a href="https://aphyr.com/">https://aphyr.com/</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>Облачная база данных Spanner, разработанная внутри Google, опирается на атомные часы, находящиеся в непосредственной близости от каждого сервера <a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">https://cloud.google.com/spanner/docs/true-time-external-consistency</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Lamport L. <em>Time, clocks, and the ordering of events in a distributed systems</em> &mdash; Communications of the ACM, 1978 &mdash; Vol. 21 &mdash; P. 558&ndash;565.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='categories'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
<span class='screen-reader-text'>Категории: </span><a class='category' href='/categories/algorithm/'>Алгоритмы</a></div>
<div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Тэги: </span><a class='tag' href='/tags/graph/'>graph</a>, <a class='tag' href='/tags/state-machine/'>state-machine</a>, <a class='tag' href='/tags/distributed-system/'>distributed system</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='/post/2019/10/rdd/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Предыдущий</span>
        <span class='screen-reader-text'>Предыдущая запись: </span>Readme Driven Development</a>
    </div><div class='next-entry sep-before'>
      <a href='/post/2020/07/logs/'>
        <span class='screen-reader-text'>Следующая запись: </span>Залогируй это<span aria-hidden='true'>Следующий <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p>Материалы распространяются по <!-- raw HTML omitted -->лицензии CC BY<!-- raw HTML omitted --> &copy; 2018-2021 vporoshok <!-- raw HTML omitted -->Увидели ошибку? Буду рад <!-- raw HTML omitted -->PR&rsquo;у<!-- raw HTML omitted --></p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="/assets/js/"</script>

<script src='/assets/js/main.67d669ac.js'></script><link rel='stylesheet' href='/assets/katex/katex.min.css'>
<script src='/assets/katex/katex.min.js'></script>
<script src='/assets/katex/contrib/auto-render.min.js'></script>

<script type='text/javascript'>
  renderMathInElement(document.querySelector('.entry-content'),{"throwOnError":true});
</script><script src='/assets/mermaid.min.js' />

<script type='text/javascript'>
  mermaid.initialize({});
</script>

</body>

</html>

