---
title: Разрешение орграфа
description:
date: 2017-06-04T17:00:30Z
categories:
- develop
tags:
- algorithm
- graph
- go
cover:
  image: /post/2017/06/img/net.jpg
  caption: Photo by Andrés Canchón on Unsplash
  style: normal
toc: true
mathjax: true
---

По работе уже не первый раз сталкиваюсь с задачей разрешения графа, например, получить полный список зависимостей пакета или получить список групп пользователя, где группы могут включать друг друга. (Вообще граф зависимостей куда сложнее текущей темы, потому как дуги имеют маски версий, так что отложим этот вопрос на будущее.)

Итак, давайте сформулируем и ограничим задачу. У нас есть (в общем случае) ориентированный граф. Каждая вершина имеет уникальное имя и связанные с ней данные. Также отметим, что этот граф очень редко меняется в сравнении с запросом на разрешение зависимостей. На вход нам даются несколько имён вершин, мы должны вернуть список вершин, которые достижимы из заданных, или из которых можно достигнуть заданные (разрешить исходящий подграф или входящий).

Для решения задачи есть 2 алгоритма: поиск в глубину и поиск в ширину. Воспользуемся поиском в ширину. Для простоты описания рассмотрим разрешение исходящего графа. Суть алгоритма сводится к следующему:
1. заведём очередь вершин графа;
2. добавим в очередь заданные на старте вершины;
3. пока очередь не пуста извлекаем вершину из очереди;
4. для всех вершин достижимых из вершины, взятой из очереди: если вершина ещё не просмотрена, то отмечаем её как просмотренную и добавляем в очередь;
5. вершину взятую из очереди помещаем в результат;

Всё достаточно просто, за исключением двух вопросов:
1. как хранить очередь, ведь если у нас окажется полный граф, то в очереди окажутся все вершины графа?
2. что значит пометим вершину как просмотренную и как потом узнать метку этой вершины?

На первый вопрос ответ содержится в шаге 5. Все вершины из очереди попадают в результат. Так если они всё равно попадут в результат, то почему бы результат и не использовать как очередь, просто завести указатель на начало очереди, а когда этот указатель догонит конец результата, это будет означать, что очередь пуста.

На второй вопрос ответ не столь прост. В постановке задачи мы упомянули, что каждая вершина имеет имя. И именно по именам происходит доступ к вершинам извне. То есть мы должны хранить вершины в хеш-таблице по их именам (или использовать деревья поиска, хотя в большинстве случаев время доступа важнее перерасхода памяти). И для хранения меток тоже хочется использовать хеш-таблицу. Но тут возникает другая проблема: одно дело хеш-таблица, которая построена один раз, а потом мы из неё читаем, совсем другое дело это строить огромную хеш-таблицу на каждый запрос. И дело даже не в расходе памяти, а в скорости её выделения/очистки. Давайте вернёмся к ограничениям: граф очень редко меняется в сравнении с запросом на разрешение зависимостей. Давайте на момент построения графа давать его вершинам числовые индексы. Тогда для хранения меток мы можем использовать булевый список длинной в количество вершин, ну, или пойти дальше и использовать битовые маски чтобы сократить количество используемой памяти ещё в 8 раз.

Вроде теперь непонятных мест не осталось, приступим к реализации:
{{< file "content/post/2017/06/git/graph-go/vertex.go" >}}

Структура `vertex` описывает вершину со связями до других вершин. Для хранения связей используется двойной список `link`. Также при добавлении связи мы должны проверить что связь не была представлена ранее, для этого используем бинарный поиск по установленным ранее связям. Метод `String` использовался для отладки, впрочем мешать не будет.

Также опишем битовый массив меток:
{{< file "content/post/2017/06/git/graph-go/labels.go" >}}

Ну, и собственно сам граф:
{{< file "content/post/2017/06/git/graph-go/graph.go" >}}

Для оптимизации работы с памятью используем 2 `sync.Pool`'а для результирующего списка/очереди и массива меток. И ещё одна оптимизация: если в результирущем списке содержатся все вершины графа, тогда можно заканчивать обход (строка 123). На сильно связанных графах это условие позволит сильно сэкономить операции.

Напоследок напишем тесты и бенчмарки:
{{< file "content/post/2017/06/git/graph-go/graph_test.go" >}}

Для бенчмарка будем строить случайный граф. Очевидно, что сложность алгоритма \\(O(m)\\), то есть прямо пропорциональна числу связей, так что зафиксируем число вершин на 500'000 и будем увеличивать число связей по 100'000 за шаг. Получим следующий график:
{{< figure src="/post/2017/06/img/resolve_time.png" title="Время обработки запроса от количества связей" >}}

На графике видно место где сработала введёная нами оптимизация (строка 123). В районе 6'000'000 связей граф становится полностью достижим и время ответа резко сокращается.

Количество памяти зависит по большей части от размеров результирующего списка:
{{< figure src="/post/2017/06/img/resolve_memory.png" title="Расход памяти от количества связей" >}}

Также в районе 6'000'000 достигает своего максимума и стабилизируется на примерно 8MB.

Вообще для сильносвязных графов надо искать другие решения, возможно предварительно высчитывать компоненты связности и хранение списков недостижимых вершин.

Весь код доступен в репозитории https://github.com/vporoshok/graph-go
