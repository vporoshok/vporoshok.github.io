---
title: 'SICP: 1.1 Элементы программирования'
description: Комбинации, переменные, функции и условные выражения
date: 2019-08-03T16:43:50Z
draft: false
categories:
- algorithm
tags:
- sicp
- scheme
toc: true
---

## Префиксная нотация и комбинации

Программа на языке Лисп представляет из себя набор комбинаций (combination) и особых форм (special form). Комбинациями называются кортежи, состоящие из команды и операндов (аргументов):
```scheme
(<op> <arg1> [...<args>])
```

В качестве операции могут выступать базовые арифметические операции, встроенные в язык (+, -, * и /). Например
```scheme
(+ 8 4)
;> 12
```
(здесь и далее ответы интерпретатора пишутся в комментарии, начинающемся с `;>`)
```scheme
(/ 128 8)
;> 16
```

Первое время кажется сложным воспринимать такую запись, где операция предшествует операндам. Такая запись называется префиксной нотацией. Но она оказывается близкой к модели выполнения программ в компьютере и достаточно понятной для человека. Также важной особенностью такой нотации является описание операций с переменным числом операндов:
```scheme
(+ 21 35 12 7)
;> 75
```
К тому же комбинации можно вкладывать друг в друга, образовывая сложные, но однозначные конструкции:
```scheme
(+ (* 3 5) (- 10 6))
;> 19
```

Но большие выражения, записанные в префиксной нотации читаются достаточно тяжело, поэтому применяется так называемая красивая печать (pretty printing), например, выражение
```scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
```
можно записать следующим образом:
```scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

В общем случае:
```scheme
(<op> arg1
      arg2
      ...)
```

## Имена и окружение

Часто необходимо переиспользовать вычисленный результат. Для этого можно давать имена результатам вычислений с помощью особой формы

```scheme
(define <name> <expr>):
```

Например,
```scheme
(define pi 3.14159)
(define radius 10)
(define circumference (* 2 pi radius))
circumference
;> 62.8318
```

Таким образом можно пошагово строить сложные выражения. Именованные значения сохраняются в окружении. Изначально есть глобальное окружение, помимо него существуют окружения подпрограмм (функций), о которых мы поговорим позже.

## Функции

Помимо именования результатов вычислений, можно также именовать выражения, формируя таким образом функции. Для этого используется специальная форма define:
```scheme
(define (<name> ...<args>) <expr>)
```
Например,
```scheme
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
```
Получившиеся функции можно использовать аналогично встроенным в язык операциям.
```scheme
(sum-of-squares 3 4)
;> 25
```

Можно определить вычисление комбинации следующим образом:
1. вычислить все подвыражения комбинации;
2. использовать результат первого подвыражения как функцию, которую применить к оставшимся подвыражениям.

Таким образом можно интерпретировать вычисление выражения
```scheme
(sum-of-squares (+ 1 2) (* 2 2))
```
следующей последовательностью преобразований:
```scheme
(sum-of-squares 3 4)      ; вычисляются все подвыражения
(+ (square 3) (square 4)) ; выполняется подстановка функции
(+ (* 3 3) (* 4 4))       ; выполняется подстановка функции
(+ 9 16)                  ; вычисляются все подвыражения
;> 25                     ; первое подвыражение применяется к остальным
```

Это не то, что реально происходит в интерпретаторе, это упрощённая модель, которой достаточно на текущем этапе. Позже мы рассмотрим случаи, когда такой модели оказывается недостаточно, и рассмотрим другую модель подстановки функций. Но уже из этой модели очевидно то, что подвыражения комбинации вычисляются до вычисления самой операции. Такая модель вычисления называется нормальным порядком вычисления. Также существует альтернативная модель, называемая аппликативным порядком или ленивыми вычислениями, когда подвыражения вычисляются в момент обращения к ним. Тогда вычисление предыдущего выражения можно представить следующей последовательностью:
```scheme
(sum-of-squares (+ 1 2) (* 2 2))
(+ (square (+ 1 2)) (square (* 2 2)))
(+ (* (+ 1 2) (+ 1 2)) (* (* 2 2) (* 2 2)))
```
После чего производится редукция выражений:
```scheme
(+ (* 3 3) (* 4 4))
(+ 9 16)
;> 25
```

И нормальный, и аппликативный порядки приводят к одинаковому результату, если все подвыражения корректно вычислимы, однако, это не всегда так (см. Упражнение 1.5).

## Условные выражения и предикаты

Для полноценного языка программирования не хватает ещё одного класса выражений: условного ветвления. Лисп предоставляет два вида условных выржений:
```scheme
(cond (<pred> <expr>)
      (<pred> <expr>)
      ...
     [(else <expr>)]))
```
и, в случае двух веток:
```scheme
(if <pred> <expr> <expr>)
```
Через `<pred>` обозначается предикат, выражение, результатом которого может быть либо ложь (`#f`), либо любое другое значение, которое будет интерпретироваться как истина (`#t`). Результатом таких выражений будет результат первого выражения с верным предикатом. Например, можно выразить функцию модуля числа следующим образом:
```scheme
(define (abs x)
    (if (< x 0)
        (- x)
        x))
```
или
```scheme
(define (abs x)
    (cond ((< x 0) (- x))
          (else x)))
```

Условные выражения являются специальными формами. При этом вычисляются только те предикаты и выражения, которые необходимы (все предикаты до первого истинного и выражение, следующее за истинным предикатом). То есть условные выражения имеют аппликативный порядок вычисления.

Базовыми предикатами являются >, < и =. Помимо них есть ещё 3 логических выражения:
```scheme
(and ...<preds>)
(or ...<preds>)
(not <pred>)
```

Выражения `and` и `or` являются особыми формами, потому что в первом случае вычисляются предикаты до первого ложного, а во втором до первого истинного. Выражения же `not` можно интерпретировать как обычную функцию.

{{<note info>}}
Кстати, при вычислении комбинаций первым пунктом является «вычислить все подвыражения». Это можно применить как к аргументам функции, так и к самой функции. Например, функцию модуля можно записать следующим образом:
```scheme
(define (abs x) ((if (< x 0) - +) x))
```

Подумайте как это можно интерпетировать. Какой будет последовательность преобразований выражения `(abs 5)`? `(abs -5)`?
{{</note>}}

## Упражнения

Упражнения представлены в курсе https://repl.it/classroom/invite/cTpCI6u