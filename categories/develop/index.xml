<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Разработка on Где-то на дальнем сервере</title>
    <link>https://vporoshok.me/categories/develop/</link>
    <description>Recent content in Разработка on Где-то на дальнем сервере</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language><atom:link href="https://vporoshok.me/categories/develop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Работа над задачей</title>
      <link>https://vporoshok.me/post/2021/04/work/</link>
      <pubDate>Fri, 09 Apr 2021 12:34:13 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2021/04/work/</guid>
      <description>Каждый день по работе я сталкиваюсь с разными задачами. Принципы работы с ними складывались как-то спонтанно, местами ценой набитых шишек. В этой статье хочу собрать всё и структурировать. В основном для себя, но вдруг окажется полезным ещё кому-нибудь.
Что важно Задачи можно решать разными способами, это как с сортировкой. В конце концов можно писать код до тех пор, пока задача не решится (возможно через пару лет усердного труда отдела программистов). Но программист не сферический конь в вакууме.</description>
    </item>
    
    <item>
      <title>Залогируй это</title>
      <link>https://vporoshok.me/post/2020/07/logs/</link>
      <pubDate>Wed, 15 Jul 2020 19:25:46 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2020/07/logs/</guid>
      <description>С самого начала моей карьеры программиста я на каждом углу встречал напутствия в стиле: «Пишите как можно больше логов, логируйте всё». Но все попытки логировать всё подряд приводили лишь к огромным файлам, в которых ничего не понять. И нигде мне не встречалось вразумительного руководства что и как надо логировать. Что ж, накопив немного опыта, давайте попробуем разобраться в этом вопросе.
Роли и задачи Прежде чем определять что писать в логи, необходимо разобраться кто и с какой целью их будет читать, ведь от модели использования будет зависеть ожидаемое содержимое.</description>
    </item>
    
    <item>
      <title>Быстро пишем функциональные тесты</title>
      <link>https://vporoshok.me/post/2019/08/quick-test/</link>
      <pubDate>Sun, 25 Aug 2019 15:44:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/quick-test/</guid>
      <description>Пара слов о классификации тестов Напомню, что традиционно выделяют следующие виды тестов:
 Модульные &amp;mdash; они же юнит-тесты. Это тесты изолированные внутри пакета/модуля, которые тестируют отдельные методы классов и помогают при разработке. Функциональные &amp;mdash; тесты, обращающиеся к пакету/модулю как к чёрному ящику, вызывая только публичные методы. Интеграционные &amp;mdash; (и их подвиды: end-to-end и сценарные тесты) проводятся в среде приближенной к рабочей, с реальными бд и другими сервисами.  Не вдаваясь в холивары, будем придерживаюсь той точки зрения, что модульные тесты это инструмент для разработки, когда есть сложная логика, которую легко протестировать.</description>
    </item>
    
    <item>
      <title>Действия в действии</title>
      <link>https://vporoshok.me/post/2019/08/actions-in-action/</link>
      <pubDate>Wed, 21 Aug 2019 03:25:57 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/actions-in-action/</guid>
      <description>В статье Чистая архитектура на Go предлагается изолировать бизнес-логику микросервиса в так называемых Действиях. В данной статье разбираются различные наработанные практики и подходы по написанию Действий.
DIContainer Практически любое действие так или иначе зависит от внешних систем, будь то база данных, файловая система, часы или логер. Всё, что связано с побочными эффектами. Собрать все зависимости в один объект, идея не новая, но в контексте Go несколько кропотливая. Итак, до создания первого действия необходимо описать зависимости.</description>
    </item>
    
    <item>
      <title>Полезные приёмы по работе с ошибками в Go</title>
      <link>https://vporoshok.me/post/2019/05/errors/</link>
      <pubDate>Sat, 04 May 2019 19:12:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/05/errors/</guid>
      <description>Язык Go поощряет использование возвращаемых ошибок, при этом не накладывая больших ограничений на то, что скрывается внутри самой ошибки. Несмотря на многословность, подобную практику можно выгодно использовать. Давайте посмотрим какие удобные способы работы есть с ошибками.
pkg/errors Первое, что необходимо включить в свой проект, это библиотеку github.com/pkg/errors, которая позволяет быстро конструировать ошибки, а также добавлять контекст и, конечно, стек вызова. Лично у меня пальцы уже автоматом набирают
return errors.WithStack(err) Одной из ключевых особенностей ошибок, созданных с помощью пакета, является то, что у них есть метод Cause, позволяющий получить первоначальную ошибку.</description>
    </item>
    
    <item>
      <title>Декораторы в Go</title>
      <link>https://vporoshok.me/post/2019/01/decorators/</link>
      <pubDate>Thu, 24 Jan 2019 16:25:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/decorators/</guid>
      <description>Довольно большая часть моей работы заключается в написании библиотечного кода. Кода, который будет многократно использоваться как другими программистами, так и мной самим. Поэтому одним из важных критериев становится удобство интерфейсов. Некоторые применяемые мной практики рассмотрены в этой статье.
Перехватчики Концепция middleware появилась, конечно, задолго до go. Будем называть их перехватчиками, что не по фен-шую, но лучше, чем «слой промежуточного программного обеспечения». Однако, именно в go эта концепция достигла своего апогея. Собственно про middleware написано и сказано уже довольно много.</description>
    </item>
    
    <item>
      <title>Рефлексия в Go</title>
      <link>https://vporoshok.me/post/2019/01/reflection/</link>
      <pubDate>Sun, 20 Jan 2019 05:30:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/reflection/</guid>
      <description>Зачем ты озабочен\
В этот хороший миг одним упорным выяснением,\
Как тебя люди другие видят. Тратишь воображение\
На домыслы пустые о домыслах касательно своей персоны.\
У тебя рефлексия, опасная стадия. Есть есть есть «Рефлексия»    Что же такое рефлексия и для чего она нужна? Рефлексия это механизм, с помощью которого программа может проверять своё состояние, исследовать типы данных и менять свою структуру и поведение во время выполнения. Звучит довольно запутано, но давайте раскладывать по полочкам.</description>
    </item>
    
    <item>
      <title>Property-based testing</title>
      <link>https://vporoshok.me/post/2018/06/property-based-testing/</link>
      <pubDate>Tue, 12 Jun 2018 16:09:44 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/property-based-testing/</guid>
      <description>Сегодня хотелось бы рассмотреть такой подход к тестированию как property-based тесты, или, по-русски говоря, тесты основанные на свойствах. Раньше, когда я слышал это название, то думал, что это способы тестирования свойств классов, в смысле property. А при учёте того, что я слышал об этом исключительно в подкасте DevZen, где за этими словами следовали слова: haskell, scala и erlang, то не особо вдавался в подробности. Однако, на выпуске про TLA+ эта тема меня всё же зацепила, так что я пошёл гуглить и читать.</description>
    </item>
    
    <item>
      <title>Чистая архитектура на Go</title>
      <link>https://vporoshok.me/post/2018/04/clean-architect/</link>
      <pubDate>Sun, 15 Apr 2018 14:14:40 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/clean-architect/</guid>
      <description>О том, что такое чистая архитектура можно почитать в оригинале, а также в переводе. Кроме того на том же хабре есть переводы статей о переложении этого подхода на Go: раз, два и три. Но все это разбивается о реальную жизнь, транзакции, переиспользование кода, протомонолит и прочие проблемы. Но обо всём по порядку.
 ⚠️Внимание!Всё описанное является сугубо моим мнением, основанным на некотором количестве боли, испытываемой в работе, особенно с циклическими импортами.</description>
    </item>
    
    <item>
      <title>Цикл статей про Angular</title>
      <link>https://vporoshok.me/post/2018/04/angular-toc/</link>
      <pubDate>Sun, 08 Apr 2018 07:24:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/angular-toc/</guid>
      <description>Мы начали использовать Angular (в то время Angular 2) на одном из проектов нашей компании примерно в сентябре 2016 года. Тогда он только вышел из беты. За плечами у нас не было опыта использования никакого фреймворка, разве что Backbone, но фреймворком его можно назвать лишь с натяжкой. Проект же требовал довольно развесистого веб-приложения. Мы немного пощупали Ember, посмотрели на React, даже попытались воспользоваться Backbone+Marionette, но в итоге остановились на Angular. Порой он причинял нам боль, порой мы упирались в совершенно необъяснимое поведение.</description>
    </item>
    
    <item>
      <title>Разрешение орграфа</title>
      <link>https://vporoshok.me/post/2017/06/orgraph-resolve/</link>
      <pubDate>Sun, 04 Jun 2017 17:00:30 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/06/orgraph-resolve/</guid>
      <description>По работе уже не первый раз сталкиваюсь с задачей разрешения графа, например, получить полный список зависимостей пакета или получить список групп пользователя, где группы могут включать друг друга. (Вообще граф зависимостей куда сложнее текущей темы, потому как дуги имеют маски версий, так что отложим этот вопрос на будущее.)
Итак, давайте сформулируем и ограничим задачу. У нас есть (в общем случае) ориентированный граф. Каждая вершина имеет уникальное имя и связанные с ней данные.</description>
    </item>
    
    <item>
      <title>Ещё раз о безопасности или где хранить токен</title>
      <link>https://vporoshok.me/post/2017/05/token-placement/</link>
      <pubDate>Sun, 28 May 2017 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/05/token-placement/</guid>
      <description>В очередной раз встал вопрос о том где и как хранить токен авторизации. Первое что приходит в голову это cookie. Итак, давайте сделаем простенький сайт со странице авторизации и использованием cookie для определения пользователя, а затем попробуем его поломать. Использовать мы будем CSRF атаку. Об этих атаках написано уже немало статей, небольшой список будет в конце. В данном посте хочется добавить практики в эти объяснения на пальцах. Для удобства используем репозиторий с тегами эволюции проекта https://github.</description>
    </item>
    
  </channel>
</rss>
