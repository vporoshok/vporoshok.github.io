<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Где-то на дальнем сервере</title>
    <link>https://vporoshok.me/</link>
    <description>Recent content on Где-то на дальнем сервере</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Fri, 09 Apr 2021 12:34:13 +0000</lastBuildDate><atom:link href="https://vporoshok.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Работа над задачей</title>
      <link>https://vporoshok.me/post/2021/04/work/</link>
      <pubDate>Fri, 09 Apr 2021 12:34:13 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2021/04/work/</guid>
      <description>Каждый день по работе я сталкиваюсь с разными задачами. Принципы работы с ними складывались как-то спонтанно, местами ценой набитых шишек. В этой статье хочу собрать всё и структурировать. В основном для себя, но вдруг окажется полезным ещё кому-нибудь.
Что важно Задачи можно решать разными способами, это как с сортировкой. В конце концов можно писать код до тех пор, пока задача не решится (возможно через пару лет усердного труда отдела программистов). Но программист не сферический конь в вакууме.</description>
    </item>
    
    <item>
      <title>Залогируй это</title>
      <link>https://vporoshok.me/post/2020/07/logs/</link>
      <pubDate>Wed, 15 Jul 2020 19:25:46 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2020/07/logs/</guid>
      <description>С самого начала моей карьеры программиста я на каждом углу встречал напутствия в стиле: «Пишите как можно больше логов, логируйте всё». Но все попытки логировать всё подряд приводили лишь к огромным файлам, в которых ничего не понять. И нигде мне не встречалось вразумительного руководства что и как надо логировать. Что ж, накопив немного опыта, давайте попробуем разобраться в этом вопросе.
Роли и задачи Прежде чем определять что писать в логи, необходимо разобраться кто и с какой целью их будет читать, ведь от модели использования будет зависеть ожидаемое содержимое.</description>
    </item>
    
    <item>
      <title>Распределённые алгоритмы</title>
      <link>https://vporoshok.me/post/2020/01/distributed-algorithms/</link>
      <pubDate>Tue, 07 Jan 2020 13:37:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2020/01/distributed-algorithms/</guid>
      <description>В этой заметке разбираются базовые понятия и определения, используемые при рассмотрении распределённых систем и алгоритмов, выполняемых на них. Терминология позаимствована из книги Уона Фоккинка «Распределенные алгоритмы. Интуитивный подход»1.
Что такое распределённая система? Определение распределённой системы базируется на определениях её базовых частей. Подходы же, применяемые в алгоритмах, рассчитанных на распределённое вычисление находят применение и за пределами распределённых систем в их базовом понимании. Поэтому будем понимать определение распредённой системы расширено.
Базовой составляющей распределённой системы является процесс.</description>
    </item>
    
    <item>
      <title>Синхронизация состояния в распределённых системах</title>
      <link>https://vporoshok.me/slides/2019/11/state-sync/</link>
      <pubDate>Sat, 16 Nov 2019 12:24:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/11/state-sync/</guid>
      <description>Синхронизация состояния в распределённых системах   Всем привет!  Бастрыков Евгений Программирую с 2013 Преподаю «Алгоритмы и структуры данных» Разрабатываю QuickBPM    План  кеш во внешнем сервисе кеш внутри сервиса шардирование   Не используйте, если можете   Кеш во внешнем сервисе   Кеш во внешнем сервисе   Кеш во внешнем сервисе Идеален, если
 чистые данные не меняются подготовка занимает время/ресурсы    Кеш во внешнем сервисе Проблемы:</description>
    </item>
    
    <item>
      <title>Readme Driven Development</title>
      <link>https://vporoshok.me/post/2019/10/rdd/</link>
      <pubDate>Sun, 13 Oct 2019 10:21:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/10/rdd/</guid>
      <description>Технари всегда начинают разговор с «нет», потому что думают о том, как это реализовывать, а тут надо «парить»… Будин А.В.   В этой статье попробуем разобраться о том, как проектировать программные интерфейсы. Интерфейсы могут быть совершенно разными, однако, есть в них одна общая черта: программисты разрабатывают их для других программистов. И это будет нашим большим плюсом, потому что мы также можем выступать в роли потребителей собственных продуктов. Итак, вы решили разработать библиотеку или сервис.</description>
    </item>
    
    <item>
      <title>SICP: 1.1 Элементы программирования</title>
      <link>https://vporoshok.me/post/2019/10/sicp-elementary/</link>
      <pubDate>Fri, 04 Oct 2019 15:17:31 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/10/sicp-elementary/</guid>
      <description>Префиксная нотация и комбинации Программа на языке Лисп представляет из себя набор комбинаций (combination) и особых форм (special form). Комбинациями называются кортежи, состоящие из команды и операндов (аргументов):
(&amp;lt;op&amp;gt; &amp;lt;arg1&amp;gt; [...&amp;lt;args&amp;gt;]) В качестве операции могут выступать базовые арифметические операции, встроенные в язык (+, -, * и /). Например
(+ 8 4) ;&amp;gt; 12 (здесь и далее ответы интерпретатора пишутся в комментарии, начинающемся с ;&amp;gt;)
(/ 128 8) ;&amp;gt; 16 Первое время кажется сложным воспринимать такую запись, где операция предшествует операндам.</description>
    </item>
    
    <item>
      <title>Быстро пишем функциональные тесты</title>
      <link>https://vporoshok.me/post/2019/08/quick-test/</link>
      <pubDate>Sun, 25 Aug 2019 15:44:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/quick-test/</guid>
      <description>Пара слов о классификации тестов Напомню, что традиционно выделяют следующие виды тестов:
 Модульные &amp;mdash; они же юнит-тесты. Это тесты изолированные внутри пакета/модуля, которые тестируют отдельные методы классов и помогают при разработке. Функциональные &amp;mdash; тесты, обращающиеся к пакету/модулю как к чёрному ящику, вызывая только публичные методы. Интеграционные &amp;mdash; (и их подвиды: end-to-end и сценарные тесты) проводятся в среде приближенной к рабочей, с реальными бд и другими сервисами.  Не вдаваясь в холивары, будем придерживаюсь той точки зрения, что модульные тесты это инструмент для разработки, когда есть сложная логика, которую легко протестировать.</description>
    </item>
    
    <item>
      <title>Действия в действии</title>
      <link>https://vporoshok.me/post/2019/08/actions-in-action/</link>
      <pubDate>Wed, 21 Aug 2019 03:25:57 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/actions-in-action/</guid>
      <description>В статье Чистая архитектура на Go предлагается изолировать бизнес-логику микросервиса в так называемых Действиях. В данной статье разбираются различные наработанные практики и подходы по написанию Действий.
DIContainer Практически любое действие так или иначе зависит от внешних систем, будь то база данных, файловая система, часы или логер. Всё, что связано с побочными эффектами. Собрать все зависимости в один объект, идея не новая, но в контексте Go несколько кропотливая. Итак, до создания первого действия необходимо описать зависимости.</description>
    </item>
    
    <item>
      <title>SICP: Введение</title>
      <link>https://vporoshok.me/post/2019/07/sicp-intro/</link>
      <pubDate>Tue, 30 Jul 2019 09:16:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/07/sicp-intro/</guid>
      <description>В очередной раз взялся за эту книгу, признанную фундаментальной для изучения программирования, основу для многих курсов и по сей день актуальную. Итак, знаменитая СИКП или книга Структура и интерпретация компьютерных программ. Эта книга, написанная в MIT, является классическим учебником программирования, используемым во многих университетах по всему миру.
Эта книга проводит читателя от азов программирования до сложных конструкций, вплоть до построения собственного интерпретатора языка. В ней разбирается то, как работает с кодом программ компьютер, а также то, как удобнее работать с ним человеку.</description>
    </item>
    
    <item>
      <title>Алгоритмы?! А оно мне надо?</title>
      <link>https://vporoshok.me/slides/2019/05/why-algorithm/</link>
      <pubDate>Sun, 05 May 2019 05:37:34 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/05/why-algorithm/</guid>
      <description>Алгоритмы?!А оно мне надо?  Photo by Ben White on Unsplash   Всем привет!  Бастрыков Евгений Программирую с 2013 Преподаю «Алгоритмы и структуры данных» Разрабатываю elma365    О чём доклад   Так для чего же изучать алгоритмы?   Photo by Mathew Schwartz on Unsplash   Так для чего же изучать алгоритмы?   О чём нам не говорили в школе?   Photo by Stefan Steinbauer on Unsplash   Литература учит формулировать мысли   Алгоритмы это литература   Алгоритмы это литература   Как читать книги?</description>
    </item>
    
    <item>
      <title>Полезные приёмы по работе с ошибками в Go</title>
      <link>https://vporoshok.me/post/2019/05/errors/</link>
      <pubDate>Sat, 04 May 2019 19:12:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/05/errors/</guid>
      <description>Язык Go поощряет использование возвращаемых ошибок, при этом не накладывая больших ограничений на то, что скрывается внутри самой ошибки. Несмотря на многословность, подобную практику можно выгодно использовать. Давайте посмотрим какие удобные способы работы есть с ошибками.
pkg/errors Первое, что необходимо включить в свой проект, это библиотеку github.com/pkg/errors, которая позволяет быстро конструировать ошибки, а также добавлять контекст и, конечно, стек вызова. Лично у меня пальцы уже автоматом набирают
return errors.WithStack(err) Одной из ключевых особенностей ошибок, созданных с помощью пакета, является то, что у них есть метод Cause, позволяющий получить первоначальную ошибку.</description>
    </item>
    
    <item>
      <title>O3: разговоры тет-а-тет</title>
      <link>https://vporoshok.me/post/2019/03/one-on-one/</link>
      <pubDate>Sun, 17 Mar 2019 17:35:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/03/one-on-one/</guid>
      <description>Разговоры один на один между куратором и сотрудниками часто в англоязычных источниках называются one-on-one или просто O3. Для многих компаний это обычная практика, а среди европейских it-компаний уже трудно найти ту, где такие сессии не проводятся. Так давайте разбираться что это, для чего и как.
Что же такое O3? O3 это приватная встреча между куратором и сотрудником. Такие встречи обычно проводятся раз в одну или две недели. На этих встречах обсуждаются текущее состояние сотрудника, его переживания связанные с работой, вопросы, которые не столь критичны, что требуют незамедлительной реакции, но важны в перспективе.</description>
    </item>
    
    <item>
      <title>Задачи RMQ и LCA</title>
      <link>https://vporoshok.me/slides/2019/03/rmq__lca/</link>
      <pubDate>Sat, 09 Mar 2019 04:07:12 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/03/rmq__lca/</guid>
      <description>\[ \gdef\rmq{\mathop{\mathrm{rmq}}} \gdef\lca{\mathop{\mathrm{lca}}} \gdef\new{\mathop{\mathrm{new}}} \]  Задачи RMQ и LCA   План  задача и применение RMQ -&amp;gt; LCA offline LCA online RMQ ±1 RMQ LCA -&amp;gt; ±1 RMQ    Задача и применение   Задача и применение RMQ (range minimum query) Выбор наименьшего элемента в отрезке индексов.
Дано: \(A = \{a_k \colon k &amp;lt; n \}\).
Операции:
 \(\rmq(i, j) = \min\{a_k \colon i \leqslant k \leqslant j\}\).</description>
    </item>
    
    <item>
      <title>Семейство непересекающихся множеств</title>
      <link>https://vporoshok.me/slides/2019/03/dsu/</link>
      <pubDate>Fri, 08 Mar 2019 14:57:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/03/dsu/</guid>
      <description>DSU   Семейство непересекающихся множеств   План  задача и применение ранговая эвристика сжатие путей статистики динамический направленный лес вариант реализации    Задача и применение   Задача и применение Дано множество \(E = \{x_i\colon i &amp;lt; n\}\) &amp;mdash; Универсум.
В каждый момент времени существует разбиение
такое, что
  Задача и применение На семействе \(\mathbb X\) определим 2 операции:
  Задача и применение Находит применение в решении задач</description>
    </item>
    
    <item>
      <title>Хеш-таблицы</title>
      <link>https://vporoshok.me/slides/2019/02/hashing/</link>
      <pubDate>Fri, 01 Mar 2019 16:43:34 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/02/hashing/</guid>
      <description>Хеш-таблицы   План  задача и применение неконстантные решения хеширование коллизии анализ сложности с допущениями без допущений    Задача и применение   Задача и применение Есть множество пар \((k, v)\) &amp;mdash; ключ-значение. Необходимо построить структуру хранения этих пар так, чтобы на ней были определены операции:
 set(k, v) get(k) delete(k)    Неконстантные решения   Неконстантные решения   Хеширование   Хеширование Выделим массив для хранения пар размера \(N\), при этом допустимое множество ключей \(K\) такое, что \(|K| \gg N\).</description>
    </item>
    
    <item>
      <title>Не пишите CSS</title>
      <link>https://vporoshok.me/slides/2019/02/utility-classes/</link>
      <pubDate>Sun, 24 Feb 2019 10:31:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/02/utility-classes/</guid>
      <description>Photo by Lubo Minar on Unsplash   Как сверстать?   Всем привет!   План  Исторический экскурс и семантическая вёрстка Проблемы CSS OOCSS и БЭМ Проблемы контейнеров Препроцессоры Проблемы препроцессоров Как перестать писать CSS? Что дальше?    Исторический экскурси семантическая вёрстка   Photo by Jenny Marvin on Unsplash   Сначала был HTML HTML 3.2 (1997)
&amp;lt;img align=&amp;#34;right&amp;#34; src=&amp;#34;alice.jpg&amp;#34; /&amp;gt; &amp;lt;font face=&amp;#34;Arial&amp;#34; size=&amp;#34;4&amp;#34; color=&amp;#34;firebrick&amp;#34;&amp;gt; Похоже на экспорт Word&amp;#39;а &amp;lt;/font&amp;gt;  CSS 1.</description>
    </item>
    
    <item>
      <title>Декораторы в Go</title>
      <link>https://vporoshok.me/post/2019/01/decorators/</link>
      <pubDate>Thu, 24 Jan 2019 16:25:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/decorators/</guid>
      <description>Довольно большая часть моей работы заключается в написании библиотечного кода. Кода, который будет многократно использоваться как другими программистами, так и мной самим. Поэтому одним из важных критериев становится удобство интерфейсов. Некоторые применяемые мной практики рассмотрены в этой статье.
Перехватчики Концепция middleware появилась, конечно, задолго до go. Будем называть их перехватчиками, что не по фен-шую, но лучше, чем «слой промежуточного программного обеспечения». Однако, именно в go эта концепция достигла своего апогея. Собственно про middleware написано и сказано уже довольно много.</description>
    </item>
    
    <item>
      <title>Рефлексия в Go</title>
      <link>https://vporoshok.me/post/2019/01/reflection/</link>
      <pubDate>Sun, 20 Jan 2019 05:30:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/reflection/</guid>
      <description>Зачем ты озабочен\
В этот хороший миг одним упорным выяснением,\
Как тебя люди другие видят. Тратишь воображение\
На домыслы пустые о домыслах касательно своей персоны.\
У тебя рефлексия, опасная стадия. Есть есть есть «Рефлексия»    Что же такое рефлексия и для чего она нужна? Рефлексия это механизм, с помощью которого программа может проверять своё состояние, исследовать типы данных и менять свою структуру и поведение во время выполнения. Звучит довольно запутано, но давайте раскладывать по полочкам.</description>
    </item>
    
    <item>
      <title>Хакатон. Как не перестать улыбаться за 24 часа</title>
      <link>https://vporoshok.me/post/2019/01/hackathon/</link>
      <pubDate>Thu, 03 Jan 2019 08:08:58 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/hackathon/</guid>
      <description>Что же такое хакатон? Термин «хакатон» является словослиянием двух слов: хак (hack) и марафон (marathon).
Впервые это слово появляется в 1999 году независимо друг от друга на двух событиях: встреча разработчиков OpenBSD и конференция JavaOne. В первом случае 10 человек в течении дня разрабатывали криптографические программы, которые бы обходили ограничения США на экспорт криптографических систем, а во втором случае всем желающим было предложено в течении конференции разработать программу на Java для Palm V с использованием ИК-порта.</description>
    </item>
    
    <item>
      <title>Хакатон. Как не перестать улыбаться за 24 часа</title>
      <link>https://vporoshok.me/slides/2018/12/hackathon/</link>
      <pubDate>Tue, 25 Dec 2018 12:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/12/hackathon/</guid>
      <description>ХакатонКак не перестать улыбаться за 24 часа  Всем привет!   План  Что такое хакатон? Кто такие хакеры? Хакатон vs Работа Виды и задачи хакатонов Подготовка    Что такое хакатон?   Photo by Emily Morter on Unsplash   Что такое хакатон? Hackathon = hack + marathon 4 июня 1999 &amp;mdash; OpenBSD 15&amp;ndash;19 июня 1999 &amp;mdash; JavaOne    Кто такие хакеры?      Кто такие хакеры?</description>
    </item>
    
    <item>
      <title>Деревья поиска. АВЛ-деревья</title>
      <link>https://vporoshok.me/post/2018/12/search-tree/</link>
      <pubDate>Thu, 20 Dec 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/12/search-tree/</guid>
      <description>Большие объёмы данных требуют особых подходов к задаче поиска. Если для нахождения элемента среди пары сотен элементов за линейное время достаточно хорошо, то когда речь идёт о тысячах и миллионах элементов, линейное время оказывается неоправданно большим. Можно воспользоваться известным нам бинарным поиском или даже его адаптацией галопированием. Но и это оказывается неэффективно при работе с данными, не влезающими в оперативную память. Действительно, пусть у нас есть файл размера 1 Гб с отсортированными данными.</description>
    </item>
    
    <item>
      <title>Как и для чего изучать алгоритмы</title>
      <link>https://vporoshok.me/post/2018/11/introduction/</link>
      <pubDate>Thu, 29 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/introduction/</guid>
      <description>Иногда студенты, коллеги и знакомые задают мне вопросы о том
 почему нужно изучать алгоритмы? какой смысл в понимании оценок алгоритмов? для чего так много времени уделять алгоритмам, которые реализованы в стандартных библиотеках? пригождаются ли все эти знания в повседневной работе программиста? стоит ли разбираться javascript-разработчику с тем во что компилируется код на C и ассемблером вообще?  Отрывочно я старался отвечать на эти вопросы и раньше, однако теперь у меня сложилось более или менее целостное представление обо всех этих и многих других вопросах, кое я и попытаюсь изложить в этой статье.</description>
    </item>
    
    <item>
      <title>Кучи с эффективным слиянием</title>
      <link>https://vporoshok.me/post/2018/11/meldable-heaps/</link>
      <pubDate>Thu, 15 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/meldable-heaps/</guid>
      <description>В статье про двоичную кучу было рассказано про устройство такой структуры данных как куча, а также приведён пример реализации в виде двоичной кучи. Такая реализация обладает двумя бесспорными преимуществами: простотой и компактностью хранения. Однако одна операция, часто требуемая от кучи в ней имеет слишком высокую сложность, эта операция слияние (meld). По сути лучшим способом слияния двоичных куч является построение новой кучи на объединённом массиве элементов. Сложность такой операции будет \(O(n + m)\) или, если одна из сливаемых куч сильно меньше другой, то можно поэлементно добавить первую ко второй, получив сложность \(O(n \log m)\).</description>
    </item>
    
    <item>
      <title>Кучи с эффективным слиянием</title>
      <link>https://vporoshok.me/slides/2018/11/meldable-heaps/</link>
      <pubDate>Thu, 15 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/11/meldable-heaps/</guid>
      <description>Кучи с эффективным слиянием   План   Задача и применение   Задача и применение Операция слияния куч находит применение в таких алгоритмах, как многопутевые слияния, поиск кратчайшего пути в графе и других. Вместо добавления новых элементов по одному.  Биномиальные кучи   Биномиальные кучи  Биномиальная куча лес, состоящий из биномиальных деревьев    Биномиальные деревья subgraph k = 2 D(( )) D --- E(( )) D --- F(( )) F --- G(( )) end subgraph k = 1 B(( )) B --- C(( )) end subgraph k = 0 A(( )) end  &amp;lt;/figcaption&amp;gt;    Биномиальные деревья Биномиальное дерево порядка \(0\) состоит из одной вершины, а биномиальное дерево порядка \(k\) является объединением двух деревьев порядка \(k - 1\) так, что корень одного из них является сыном корня другого.</description>
    </item>
    
    <item>
      <title>Слияние больших массивов данных</title>
      <link>https://vporoshok.me/post/2018/11/merge-sort-2/</link>
      <pubDate>Thu, 08 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/merge-sort-2/</guid>
      <description>Итак, изучив кучи в первом приближении, можно вернуться к сортировке слиянием и рассмотреть те случаи, где другая сортировка работать не будет в принципе. Речь на этот раз пойдёт о таких объёмах данных, которые не влезают в оперативную (внутреннюю) память.
Об уровнях памяти Часто, говоря о памяти компьютера, предлагают рассматривать лишь оперативную (RAM) и дисковую (HDD / SSD). На самом деле уровней памяти в современном компьютере значительно больше. Если упростить некоторые вещи, то можно рассматривать следующую иерархию:</description>
    </item>
    
    <item>
      <title>Простая двоичная куча</title>
      <link>https://vporoshok.me/post/2018/11/simple-heap/</link>
      <pubDate>Fri, 02 Nov 2018 15:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/simple-heap/</guid>
      <description>Часто возникает необходимость «сортировать» динамический набор данных. Самым ярким примером такой задачи является очередь с приоритетом. По сути задача сводится к последовательному выбору минимумов из множества, при этом допускающего добавление к множеству новых элементов. Конечно, эту задачу можно решить с помощью сортировки начального множества, а новые элементы можно включать с помощью бинарной вставки. Однако, есть структуры данных, позволяющие реализовать необходимые операции за меньшую стоимость. Такая структура называется куча (heap).
Определение и базовые операции Кучей называется дерево, в котором любой элемент не меньше своего родителя.</description>
    </item>
    
    <item>
      <title>Простая двоичная куча</title>
      <link>https://vporoshok.me/slides/2018/11/simple-heap/</link>
      <pubDate>Fri, 02 Nov 2018 15:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/11/simple-heap/</guid>
      <description>Двоичная куча   План  задача и применение куча: определение и базовые операции двоичная куча: определение и индексация реализация базовых операций другие операции и итераторы эффективное построение кучи пирамидальная сортировка    Задача и применение   Задача  Очередь с приоритетом вектор с координатами из линейно упорядоченного множества, на котором определены две операции:  добавление элемента извлечение минимума      Применение  слияние нескольких массивов выбор пордяковых статистик частичная сортировка данных поиск кратчайшего пути построение минимального остова графа    Решения?</description>
    </item>
    
    <item>
      <title>Сортировка слиянием</title>
      <link>https://vporoshok.me/post/2018/10/merge-sort/</link>
      <pubDate>Sat, 27 Oct 2018 08:53:31 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/10/merge-sort/</guid>
      <description>Сортировка слиянием один из тех редких алгоритмов, которые не устаревают, а напротив год от года развивается, получает новые публикации и исследования. Это действительно чудесный со многих сторон алгоритм, который находит применение в современном мире, а исследования, связанные с ним предлагают решения, применимые далеко за пределами сортировки. Это своего рода жемчужина среди всех алгоритмов сортировки.
Базовый алгоритм Mergesort является двойственным к быстрой сортировке и относится к классу алгоритмов «Разделяй и властвуй». Основной функцией этого алгоритма является функция слияния, которая получает на вход два отсортированных массива и возвращает их отсортированное объединение.</description>
    </item>
    
    <item>
      <title>Разочарование в ревью кода</title>
      <link>https://vporoshok.me/post/2018/08/code-review/</link>
      <pubDate>Sat, 18 Aug 2018 16:51:41 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/08/code-review/</guid>
      <description>⚠️Внимание!В этой статье я лишь поднимаю проблемы и вопросы, не давая ответы, потому что не знаю их на сегодняшний день. При этом всё, что описано в статье, лишь мой опыт и не претендует на истину в последней инстанции. На протяжении последних нескольких лет я довольно активно пропагандировал ревью кода. Когда я только пришёл в компанию, в том отделе, куда меня взяли, не применялся даже git, а о ревью кода и вовсе не слышали.</description>
    </item>
    
    <item>
      <title>Отдельный блог</title>
      <link>https://vporoshok.me/post/2018/06/goto-standalone-blog/</link>
      <pubDate>Sat, 16 Jun 2018 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/goto-standalone-blog/</guid>
      <description>Уже несколько раз я пытался вести собственный блог. Какое-то время вёл ЖЖ, по большей части похожий на дневник. Потом я несколько раз пытался завести технический блог, но хватало меня на пару постов, после чего всё угасало. И вот недавно я всё же решил вести технический блог на регулярной основе (регулярностью, конечно, и не пахнет, но всё же). Несмотря на то, что я уже пробовал различные генераторы статических сайтов, сделал выбор в сторону платформы и завёл https://medium.</description>
    </item>
    
    <item>
      <title>Property-based testing</title>
      <link>https://vporoshok.me/post/2018/06/property-based-testing/</link>
      <pubDate>Tue, 12 Jun 2018 16:09:44 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/property-based-testing/</guid>
      <description>Сегодня хотелось бы рассмотреть такой подход к тестированию как property-based тесты, или, по-русски говоря, тесты основанные на свойствах. Раньше, когда я слышал это название, то думал, что это способы тестирования свойств классов, в смысле property. А при учёте того, что я слышал об этом исключительно в подкасте DevZen, где за этими словами следовали слова: haskell, scala и erlang, то не особо вдавался в подробности. Однако, на выпуске про TLA+ эта тема меня всё же зацепила, так что я пошёл гуглить и читать.</description>
    </item>
    
    <item>
      <title>Чистая архитектура на Go</title>
      <link>https://vporoshok.me/post/2018/04/clean-architect/</link>
      <pubDate>Sun, 15 Apr 2018 14:14:40 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/clean-architect/</guid>
      <description>О том, что такое чистая архитектура можно почитать в оригинале, а также в переводе. Кроме того на том же хабре есть переводы статей о переложении этого подхода на Go: раз, два и три. Но все это разбивается о реальную жизнь, транзакции, переиспользование кода, протомонолит и прочие проблемы. Но обо всём по порядку.
 ⚠️Внимание!Всё описанное является сугубо моим мнением, основанным на некотором количестве боли, испытываемой в работе, особенно с циклическими импортами.</description>
    </item>
    
    <item>
      <title>Чек-лист разработчика</title>
      <link>https://vporoshok.me/post/2018/04/developer-check-list/</link>
      <pubDate>Sun, 08 Apr 2018 07:49:35 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/developer-check-list/</guid>
      <description>Всегда В первую очередь надо не забывать о правилах хорошего тона. Оскорбления не разрешаются никому и никогда. Мат тоже желательно исключить из лексикона. Мы должны работать вместе, а не против друг друга, поэтому иногда надо идти на компромиссы. Ясно и чётко излагай свои мысли, аргументируй и доказывай, и тебя услышат.
TL;DR Git
 сообщение должно точно описано где, что и почему было сделано; обновление завендоренных зависимостей, изменения, не относящиеся напрямую к задаче и правки по ревью всегда оформляются отдельным коммитом;  Отчёты</description>
    </item>
    
    <item>
      <title>Цикл статей про Angular</title>
      <link>https://vporoshok.me/post/2018/04/angular-toc/</link>
      <pubDate>Sun, 08 Apr 2018 07:24:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/angular-toc/</guid>
      <description>Мы начали использовать Angular (в то время Angular 2) на одном из проектов нашей компании примерно в сентябре 2016 года. Тогда он только вышел из беты. За плечами у нас не было опыта использования никакого фреймворка, разве что Backbone, но фреймворком его можно назвать лишь с натяжкой. Проект же требовал довольно развесистого веб-приложения. Мы немного пощупали Ember, посмотрели на React, даже попытались воспользоваться Backbone+Marionette, но в итоге остановились на Angular. Порой он причинял нам боль, порой мы упирались в совершенно необъяснимое поведение.</description>
    </item>
    
    <item>
      <title>Разрешение орграфа</title>
      <link>https://vporoshok.me/post/2017/06/orgraph-resolve/</link>
      <pubDate>Sun, 04 Jun 2017 17:00:30 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/06/orgraph-resolve/</guid>
      <description>По работе уже не первый раз сталкиваюсь с задачей разрешения графа, например, получить полный список зависимостей пакета или получить список групп пользователя, где группы могут включать друг друга. (Вообще граф зависимостей куда сложнее текущей темы, потому как дуги имеют маски версий, так что отложим этот вопрос на будущее.)
Итак, давайте сформулируем и ограничим задачу. У нас есть (в общем случае) ориентированный граф. Каждая вершина имеет уникальное имя и связанные с ней данные.</description>
    </item>
    
    <item>
      <title>Ещё раз о безопасности или где хранить токен</title>
      <link>https://vporoshok.me/post/2017/05/token-placement/</link>
      <pubDate>Sun, 28 May 2017 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/05/token-placement/</guid>
      <description>В очередной раз встал вопрос о том где и как хранить токен авторизации. Первое что приходит в голову это cookie. Итак, давайте сделаем простенький сайт со странице авторизации и использованием cookie для определения пользователя, а затем попробуем его поломать. Использовать мы будем CSRF атаку. Об этих атаках написано уже немало статей, небольшой список будет в конце. В данном посте хочется добавить практики в эти объяснения на пальцах. Для удобства используем репозиторий с тегами эволюции проекта https://github.</description>
    </item>
    
    <item>
      <title>Всем привет!</title>
      <link>https://vporoshok.me/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/page/about/</guid>
      <description>Меня зовут Евгений. Я работаю программистом с 2013 года. Начинал с маленьких проектов на Python и PHP. Последнее время разрабатываю в основном на языке Go. Занимаюсь архитектурой инфраструктуры и отдельных сервисов для облачного решения по управлению бизнес-процессами. Преподаю алгоритмы и дискретную математику в УдГУ. Люблю гулять с собакой и читать книги. Увлекаюсь музыкой.
На данном сайте я высказываю свою личную точку зрения. Моё мнение может расходиться с мнением компаний, в которых я работаю.</description>
    </item>
    
  </channel>
</rss>
