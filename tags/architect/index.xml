<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>architect on Где-то на дальнем сервере</title>
    <link>https://vporoshok.me/tags/architect/</link>
    <description>Recent content in architect on Где-то на дальнем сервере</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Sun, 13 Oct 2019 10:21:26 +0000</lastBuildDate><atom:link href="https://vporoshok.me/tags/architect/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Readme Driven Development</title>
      <link>https://vporoshok.me/post/2019/10/rdd/</link>
      <pubDate>Sun, 13 Oct 2019 10:21:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/10/rdd/</guid>
      <description>Технари всегда начинают разговор с «нет», потому что думают о том, как это реализовывать, а тут надо «парить»… Будин А.В.   В этой статье попробуем разобраться о том, как проектировать программные интерфейсы. Интерфейсы могут быть совершенно разными, однако, есть в них одна общая черта: программисты разрабатывают их для других программистов. И это будет нашим большим плюсом, потому что мы также можем выступать в роли потребителей собственных продуктов. Итак, вы решили разработать библиотеку или сервис.</description>
    </item>
    
    <item>
      <title>Действия в действии</title>
      <link>https://vporoshok.me/post/2019/08/actions-in-action/</link>
      <pubDate>Wed, 21 Aug 2019 03:25:57 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/08/actions-in-action/</guid>
      <description>В статье Чистая архитектура на Go предлагается изолировать бизнес-логику микросервиса в так называемых Действиях. В данной статье разбираются различные наработанные практики и подходы по написанию Действий.
DIContainer Практически любое действие так или иначе зависит от внешних систем, будь то база данных, файловая система, часы или логер. Всё, что связано с побочными эффектами. Собрать все зависимости в один объект, идея не новая, но в контексте Go несколько кропотливая. Итак, до создания первого действия необходимо описать зависимости.</description>
    </item>
    
    <item>
      <title>Полезные приёмы по работе с ошибками в Go</title>
      <link>https://vporoshok.me/post/2019/05/errors/</link>
      <pubDate>Sat, 04 May 2019 19:12:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/05/errors/</guid>
      <description>Язык Go поощряет использование возвращаемых ошибок, при этом не накладывая больших ограничений на то, что скрывается внутри самой ошибки. Несмотря на многословность, подобную практику можно выгодно использовать. Давайте посмотрим какие удобные способы работы есть с ошибками.
pkg/errors Первое, что необходимо включить в свой проект, это библиотеку github.com/pkg/errors, которая позволяет быстро конструировать ошибки, а также добавлять контекст и, конечно, стек вызова. Лично у меня пальцы уже автоматом набирают
return errors.WithStack(err) Одной из ключевых особенностей ошибок, созданных с помощью пакета, является то, что у них есть метод Cause, позволяющий получить первоначальную ошибку.</description>
    </item>
    
    <item>
      <title>Декораторы в Go</title>
      <link>https://vporoshok.me/post/2019/01/decorators/</link>
      <pubDate>Thu, 24 Jan 2019 16:25:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/decorators/</guid>
      <description>Довольно большая часть моей работы заключается в написании библиотечного кода. Кода, который будет многократно использоваться как другими программистами, так и мной самим. Поэтому одним из важных критериев становится удобство интерфейсов. Некоторые применяемые мной практики рассмотрены в этой статье.
Перехватчики Концепция middleware появилась, конечно, задолго до go. Будем называть их перехватчиками, что не по фен-шую, но лучше, чем «слой промежуточного программного обеспечения». Однако, именно в go эта концепция достигла своего апогея. Собственно про middleware написано и сказано уже довольно много.</description>
    </item>
    
    <item>
      <title>Рефлексия в Go</title>
      <link>https://vporoshok.me/post/2019/01/reflection/</link>
      <pubDate>Sun, 20 Jan 2019 05:30:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/reflection/</guid>
      <description>Зачем ты озабочен\
В этот хороший миг одним упорным выяснением,\
Как тебя люди другие видят. Тратишь воображение\
На домыслы пустые о домыслах касательно своей персоны.\
У тебя рефлексия, опасная стадия. Есть есть есть «Рефлексия»    Что же такое рефлексия и для чего она нужна? Рефлексия это механизм, с помощью которого программа может проверять своё состояние, исследовать типы данных и менять свою структуру и поведение во время выполнения. Звучит довольно запутано, но давайте раскладывать по полочкам.</description>
    </item>
    
    <item>
      <title>Чистая архитектура на Go</title>
      <link>https://vporoshok.me/post/2018/04/clean-architect/</link>
      <pubDate>Sun, 15 Apr 2018 14:14:40 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/clean-architect/</guid>
      <description>О том, что такое чистая архитектура можно почитать в оригинале, а также в переводе. Кроме того на том же хабре есть переводы статей о переложении этого подхода на Go: раз, два и три. Но все это разбивается о реальную жизнь, транзакции, переиспользование кода, протомонолит и прочие проблемы. Но обо всём по порядку.
 ⚠️Внимание!Всё описанное является сугубо моим мнением, основанным на некотором количестве боли, испытываемой в работе, особенно с циклическими импортами.</description>
    </item>
    
  </channel>
</rss>
